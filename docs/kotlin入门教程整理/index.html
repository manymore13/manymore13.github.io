<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://manymore13.github.io/kotlin%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E6%95%B4%E7%90%86/">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Kotlin入门教程整理 - manymore13</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">manymore13</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" class="nav-link">技术</a>
                            </li>
                            <li class="navitem">
                                <a href="../%E9%87%91%E8%9E%8D%E5%88%86%E4%BA%AB/" class="nav-link">金融</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#kotlin" class="nav-link">Kotlin入门教程整理</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#kotlin_1" class="nav-link">Kotlin基础语法</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_14" class="nav-link">范型</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_15" class="nav-link">零散点记</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_17" class="nav-link">参考链接</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="kotlin">Kotlin入门教程整理</h1>
<hr />
<h2 id="kotlin_1">Kotlin基础语法</h2>
<blockquote>
<p>在 Kotlin 中，所有东西都是对象</p>
</blockquote>
<h3 id="_1">注释</h3>
<p>与大多数现代语言一样，Kotlin 支持单行（或行末）与多行（块）注释。</p>
<pre><code class="language-kotlin">// 这是单行注释

/* 这是多行
   块注释。 */

// Kotlin 中的块注释可以嵌套
/* 注释从这里开始
/* 包含嵌套的注释 */ 

并且在这里结束。 */

</code></pre>
<h3 id="_2">类型声明</h3>
<ul>
<li><strong>使用关键字val 定义只读局部变量，只能为其赋值一次</strong></li>
</ul>
<pre><code class="language-kotlin">val a: Int = 1  // 立即赋值
val b = 2   // 自动推断出 `Int` 类型
val c: Int  // 如果没有初始值类型不能省略
c = 3       // 明确赋值

</code></pre>
<ul>
<li><strong>使用 var 关键字, 可重新赋值的变量</strong></li>
</ul>
<pre><code class="language-kotlin">// 自动推断出 `Int` 类型

var x = 5 

x += 1
</code></pre>
<h3 id="_3">字符串模板</h3>
<pre><code class="language-kotlin">var a = 1
// 模板中的简单名称：
val s1 = &quot;a is $a&quot; 

a = 2
// 模板中的任意表达式：
val s2 = &quot;${s1.replace(&quot;is&quot;, &quot;was&quot;)}, but now is $a&quot;
</code></pre>
<h3 id="_4">声明函数返回值类型</h3>
<ol>
<li>使用关键字<strong>fun</strong>定义<strong>sum</strong>函数，两个<strong>Int</strong>参数，返回<strong>Int</strong>函数</li>
</ol>
<pre><code class="language-kotlin">fun sum(x:Int, y:Int): Int {return x+y}
</code></pre>
<ol>
<li>将表达式作为函数体、返回值类型自动推断的函数</li>
</ol>
<pre><code class="language-kotlin">fun sum(a: Int, b: Int) = a + b
</code></pre>
<ol>
<li>函数返回无意义的值</li>
</ol>
<pre><code class="language-kotlin">fun printSum(a: Int, b: Int): Unit {
    println(&quot;sum of $a and $b is ${a + b}&quot;)
}
</code></pre>
<p>Unit 返回类型可以省略</p>
<pre><code class="language-kotlin">fun printSum(a: Int, b: Int) {
    println(&quot;sum of $a and $b is ${a + b}&quot;)
}
</code></pre>
<h3 id="_5">条件表达式</h3>
<pre><code class="language-kotlin">fun maxof(a: Int, b: Int): Int {
    if (a &gt; b) {
        return a
    } else {
        return b
    }
}
</code></pre>
<p>也可以这么写</p>
<pre><code class="language-kotlin">fun maxOf(a: Int, b: Int) = if (a &gt; b) a else b
</code></pre>
<h3 id="null">空值与 null 检测</h3>
<p>当某个变量的值可以为 null 的时候，必须在声明处的类型后添加?来标识该引用可为空。</p>
<pre><code class="language-kotlin">// 如果 str 的内容不是数字返回 null
fun parseInt(str: String): Int? {
    // ……
}
// 使用返回可空值的函数
fun printProduct(arg1: String, arg2: String) {
    val x = parseInt(arg1)
    val y = parseInt(arg2)

    // 直接使用 `x * y` 会导致编译错误，因为它们可能为 null
    if (x != null &amp;&amp; y != null) {
        // 在空检测后，x 与 y 会自动转换为非空值（non-nullable）
        println(x * y)
    }
    else {
        println(&quot;'$arg1' or '$arg2' is not a number&quot;)
    }    
}

// 或者这么使用
if (x == null) {
    println(&quot;Wrong number format in arg1: '$arg1'&quot;)
    return
}
if (y == null) {
    println(&quot;Wrong number format in arg2: '$arg2'&quot;)
    return
}

// 在空检测后，x 与 y 会自动转换为非空值
println(x * y)
</code></pre>
<h3 id="_6">类型检测与自动类型转换</h3>
<p>is 运算符检测一个表达式是否某类型的一个实例。 如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换。</p>
<pre><code class="language-kotlin">// eg1
fun getStringLength(obj: Any): Int? {
    if (obj is String) {
        // `obj` 在该条件分支内自动转换成 `String`
        return obj.length
    }

    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型
    return null
}
// eg2
fun getStringLength(obj: Any): Int? {
    if (obj !is String) return null

    // `obj` 在这一分支自动转换为 `String`
    return obj.length
}
// eg3
fun getStringLength(obj: Any): Int? {
    // `obj` 在 `&amp;&amp;` 右边自动转换成 `String` 类型
    if (obj is String &amp;&amp; obj.length &gt; 0) {
      return obj.length
    }

    return null
}

</code></pre>
<h3 id="_7">循环</h3>
<ol>
<li>for循环</li>
</ol>
<pre><code class="language-kotlin">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)
for (item in items) {
    println(item)
}
</code></pre>
<pre><code class="language-kotlin">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)
for (index in items.indices) {
    println(&quot;item at $index is ${items[index]}&quot;)
}
</code></pre>
<ol>
<li>while循环</li>
</ol>
<pre><code class="language-kotlin">val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)
var index = 0
while (index &lt; items.size) {
    println(&quot;item at $index is ${items[index]}&quot;)
    index++
}
</code></pre>
<ol>
<li>when表达式</li>
</ol>
<pre><code class="language-kotlin">fun describe(obj: Any): String =
    when (obj) {
        1          -&gt; &quot;One&quot;
        &quot;Hello&quot;    -&gt; &quot;Greeting&quot;
        is Long    -&gt; &quot;Long&quot;
        !is String -&gt; &quot;Not a string&quot;
        else       -&gt; &quot;Unknown&quot;
    }
</code></pre>
<ol>
<li>使用区间（range）
使用 in 运算符来检测某个数字是否在指定区间内</li>
</ol>
<pre><code class="language-kotlin">val x = 10
val y = 9
if (x in 1..y+1) {
    println(&quot;fits in range&quot;)
}
</code></pre>
<p>检测某个数字是否在指定区间外</p>
<pre><code class="language-kotlin">val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

if (-1 !in 0..list.lastIndex) {
    println(&quot;-1 is out of range&quot;)
}
if (list.size !in list.indices) {
    println(&quot;list size is out of valid list indices range, too&quot;)
}
</code></pre>
<p>区间迭代</p>
<pre><code class="language-kotlin">for (x in 1..5) {
    print(x)
}
</code></pre>
<p>数列迭代</p>
<pre><code class="language-kotlin">for (x in 1..10 step 2) {
    print(x)
}
println()
for (x in 9 downTo 0 step 3) {
    print(x)
}
</code></pre>
<h3 id="_8">集合</h3>
<ol>
<li>对集合进行迭代</li>
</ol>
<pre><code class="language-kotlin">for (item in items) {
    println(item)
}
</code></pre>
<ol>
<li>使用 in 运算符来判断集合内是否包含某实例</li>
</ol>
<pre><code class="language-kotlin">when {
    &quot;orange&quot; in items -&gt; println(&quot;juicy&quot;)
    &quot;apple&quot; in items -&gt; println(&quot;apple is fine too&quot;)
}
</code></pre>
<ol>
<li>使用 lambda 表达式来过滤（filter）与映射（map）集合</li>
</ol>
<pre><code class="language-kotlin">val fruits = listOf(&quot;banana&quot;, &quot;avocado&quot;, &quot;apple&quot;, &quot;kiwifruit&quot;)
fruits
  .filter { it.startsWith(&quot;a&quot;) }
  .sortedBy { it }
  .map { it.toUpperCase() }
  .forEach { println(it) }
</code></pre>
<h3 id="_9">创建基本类及其实例</h3>
<pre><code class="language-kotlin">val rectangle = Rectangle(5.0, 2.0)
val triangle = Triangle(3.0, 4.0, 5.0)
</code></pre>
<ol>
<li>类的修饰符</li>
</ol>
<pre><code class="language-kotlin">// 类属性修饰符
abstract    // 抽象类  
final       // 类不可继承，默认属性
enum        // 枚举类
open        // 类可继承，类默认是final的
annotation  // 注解类

// 访问权限修饰符
private    // 仅在同一个文件中可见
protected  // 同一个文件中或子类可见
public     // 所有调用的地方都可见
internal   // 同一个模块中可见
</code></pre>
<ol>
<li>内部类与嵌套类</li>
<li>构造器</li>
</ol>
<p>在kotlin中有主，次两种构造器，写在类名后面的是<strong>主构造器</strong>，在类中的是<strong>次构造器</strong>，次构造器必须调用主构造器
，一个类最多只能有1个主构造器（也可以没有），而次构造器是没有个数限制。</p>
<p>主构造器中的参数在类的属性中使用，也可以在init代码块中使用。</p>
<pre><code class="language-kotlin">class User constructor(var name: String) {

    init{
        this.name = name
    }
    constructor(name: String, id: Int) :this(name){

    }

}
</code></pre>
<p>主构造器里直接声明属性</p>
<pre><code class="language-kotlin">class User(var name: String) {

}
// 等价于：
class User(name: String) {
  var name: String = name
}
</code></pre>
<ul>
<li>嵌套类</li>
</ul>
<pre><code class="language-kotlin">class Outer {                  // 外部类
    private val bar: Int = 1
    class Nested {             // 嵌套类
        fun foo() = 2
    }
}

fun main(args: Array&lt;String&gt;) {
    val demo = Outer.Nested().foo() // 调用格式：外部类.嵌套类.嵌套类方法/属性
    println(demo)    // == 2
}
</code></pre>
<ul>
<li>内部类<blockquote>
<p>内部类使用 inner 关键字来表示。内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数</p>
</blockquote>
</li>
</ul>
<pre><code class="language-kotlin">class Outer {
    private val bar: Int = 1
    var v = &quot;成员属性&quot;
    /**嵌套内部类**/
    inner class Inner {
        fun foo() = bar  // 访问外部类成员
        fun innerTest() {
            var o = this@Outer //获取外部类的成员变量
            println(&quot;内部类可以引用外部类的成员，例如：&quot; + o.v)
        }
    }
}

fun main(args: Array&lt;String&gt;) {
    val demo = Outer().Inner().foo()
    println(demo) //   1
    val demo2 = Outer().Inner().innerTest() 
    println(demo2)   // 内部类可以引用外部类的成员，例如：成员属性
}
</code></pre>
<p>为了消除歧义，要访问来自外部作用域的 this，我们使用this@label，其中 @label 是一个 代指 this 来源的标签。</p>
<ul>
<li>匿名内部类</li>
</ul>
<p>使用对象表达式来创建匿名内部类：</p>
<pre><code class="language-kotlin">class Test {
    var v = &quot;成员属性&quot;

    fun setInterFace(test: TestInterFace) {
        test.test()
    }
}

/**
 * 定义接口
 */
interface TestInterFace {
    fun test()
}

fun main(args: Array&lt;String&gt;) {
    var test = Test()

    /**
     * 采用对象表达式来创建接口对象，即匿名内部类的实例。
     */
    test.setInterFace(object : TestInterFace {
        override fun test() {
            println(&quot;对象表达式创建匿名内部类的实例&quot;)
        }
    })
}
</code></pre>
<h3 id="_10">接口</h3>
<p>使用 interface 关键字定义接口，允许方法有默认实现</p>
<pre><code class="language-kotlin">interface MyInterface {
    fun bar()    // 未实现
    fun foo() {  //已实现
      // 可选的方法体
      println(&quot;foo&quot;)
    }
}
</code></pre>
<p>实现接口
一个类或者对象可以实现一个或多个接口</p>
<pre><code class="language-kotlin">class Child : MyInterface {
    override fun bar() {
        // 方法体
    }
}
</code></pre>
<ul>
<li>函数重写</li>
</ul>
<p>实现多个接口时，可能会遇到同一方法继承多个实现的问题</p>
<pre><code class="language-kotlin">interface A {
    fun foo() { print(&quot;A&quot;) }   // 已实现
    fun bar()                  // 未实现，没有方法体，是抽象的
}

interface B {
    fun foo() { print(&quot;B&quot;) }   // 已实现
    fun bar() { print(&quot;bar&quot;) } // 已实现
}

class C : A {
    override fun bar() { print(&quot;bar&quot;) }   // 重写
}

class D : A, B {
    override fun foo() {
        super&lt;A&gt;.foo()
        super&lt;B&gt;.foo()
    }

    override fun bar() {
        super&lt;B&gt;.bar()
    }
}

fun main(args: Array&lt;String&gt;) {
    val d =  D()
    d.foo();
    d.bar();
}
</code></pre>
<h3 id="_11">匿名函数和高阶函数</h3>
<pre><code class="language-kotlin">/**
 * 匿名函數
 */
val stringLengFunc: (String) -&gt; Int = { input -&gt;
    input.length
}

/**
 * 高阶函数
 */
fun stringMapper(str: String, mapper: (String) -&gt; Int): Int {
    // Invoke function
    return mapper(str)
}


fun main() {
    val stringLength = stringLengFunc(&quot;Android&quot;)

    val length = stringMapper(&quot;Android1&quot;, stringLengFunc)
    println(length)

}
</code></pre>
<h3 id="_12"><a href="http://www.kotlincn.net/docs/reference/operator-overloading.html">操作符</a></h3>
<p>代码例子：</p>
<pre><code class="language-kotlin">fun main() {
    val counter1 = Counter(2)
    val counter2 = Counter(3)

    println(counter1 + counter2)

    val clock = Clock {
        100L
    }
}

data class Counter(val dayIndex: Int) {
    operator fun plus(increment: Counter): Counter {
        return Counter(dayIndex + increment.dayIndex)
    }

    operator fun minus(decrement: Int): Counter {
        return Counter(dayIndex - decrement)
    }

}

interface Clock {

    fun uptimeMillis(): Long

    companion object {
        inline operator fun invoke(crossinline block: () -&gt; Long): Clock =
                object : Clock {
                    override fun uptimeMillis(): Long = block()
                }
    }
}
</code></pre>
<h3 id="_13"><a href="https://www.kotlincn.net/docs/reference/scope-functions.html">作用域函数</a></h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>对象引用</th>
<th>返回值</th>
<th>是否时扩展函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>let</td>
<td>it</td>
<td>Lambda 表达式结果</td>
<td>是</td>
</tr>
<tr>
<td>run</td>
<td>this</td>
<td>Lambda 表达式结果</td>
<td>是</td>
</tr>
<tr>
<td>with</td>
<td>this</td>
<td>Lambda 表达式结果</td>
<td>不是：把上下文对象当作参数</td>
</tr>
<tr>
<td>apply</td>
<td>this</td>
<td>上下文对象</td>
<td>是</td>
</tr>
<tr>
<td>also</td>
<td>it</td>
<td>上下文对象</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="_14">范型</h2>
<p><a href="https://www.zhihu.com/question/20400700">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a>
out 相当于java里面的 &lt;? extend&gt;
in 相当于java里面的 &lt;? super&gt;</p>
<h2 id="_15">零散点记</h2>
<h3 id="_16">注解</h3>
<p>@file:JvmName("BarChartKit")</p>
<p>@JvmStatic</p>
<p><a href="https://www.jianshu.com/p/72d1959a7c56">Kotlin中@JvmOverloads 注解</a></p>
<p><a href="https://blog.csdn.net/lv_fq/article/details/72869124">kotlin 双冒号</a>
Kotlin 中 双冒号操作符 表示把一个方法当做一个参数，传递到另一个方法中进行使用，通俗的来讲就是引用一个方法。</p>
<h2 id="_17">参考链接</h2>
<ol>
<li><a href="https://kaixue.io/kotlin-basic-1/">Kotlin 的变量、函数和类型</a></li>
<li><a href="https://kaixue.io/kotlin-basic-2/">Kotlin 里那些「不是那么写的」</a></li>
<li><a href="https://kaixue.io/kotlin-basic-3/">Kotlin 里那些「更方便的</a></li>
<li><a href="https://blog.csdn.net/deng_hui_long/article/details/108969021">Kotlin StateFlow 搜索功能的实践 DB + NetWork</a></li>
</ol></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
