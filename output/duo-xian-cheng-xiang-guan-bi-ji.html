<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>多线程相关笔记 &mdash; manymore13'notes</title>
  <meta name="author" content="manymore13">






  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">


    <link href="/favicon.png" rel="icon">

  <link href="/theme/css/main.css" media="screen, projection"
        rel="stylesheet" type="text/css">

  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
</head>

<body>
  <header role="banner"><hgroup>
  <h1><a href="/">manymore13'notes</a></h1>
</hgroup></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
</ul>


<ul class="main-navigation">
      <li >
        <a href="/category/android_notes.html">Android_notes</a>
      </li>
      <li >
        <a href="/category/financial_notes.html">Financial_notes</a>
      </li>
      <li >
        <a href="/category/gu-zhi-gong-ju.html">估值工具</a>
      </li>
      <li class="active">
        <a href="/category/java_notes.html">Java_notes</a>
      </li>
      <li >
        <a href="/category/ji-suan-ji.html">计算机</a>
      </li>
      <li >
        <a href="/category/jie-zhi.html">价值</a>
      </li>
      <li >
        <a href="/category/life_notes.html">Life_notes</a>
      </li>
      <li >
        <a href="/category/python_notes.html">Python_notes</a>
      </li>
</ul></nav>
  <div id="main">
    <div id="content">
<div>
  <article class="hentry" role="article">
<header>
      <h1 class="entry-title">多线程相关笔记</h1>
    <p class="meta">
<time datetime="2020-01-05T14:00:00+08:00" pubdate>Sun 05 January 2020</time>    </p>
</header>

  <div class="entry-content"><ul>
<li>Android</li>
<li>多线程</li>
</ul>
<hr>
<h1>概念</h1>
<h2>同步与异步</h2>
<p>同步和异步通常用来形容一次方法调用。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。<strong>异步方法</strong>调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作</p>
<h2>并发与并行</h2>
<p>并行的多个任务是真的同时执行(多核多线程), 而对于并发来说，这个过程只是交替的，一会儿执行任务A，一会儿执行任务B，系统会不停地在两者之间切换。</p>
<h2>临界区</h2>
<p>临界区就是在同一时刻只能有一个任务访问的代码区。</p>
<div class="highlight"><pre><span></span><code><span class="kd">synchronized</span><span class="p">(</span><span class="n">syncObject</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="c1">//critical section</span>
<span class="p">}</span>
</code></pre></div>

<p>也可以用ReentrantLock来实现临界区</p>
<h2>阻塞（Blocking）和非阻塞（Non-Blocking）</h2>
<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的<strong>状态</strong>.
阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。
你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
<h2>死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）</h2>
<p><a href="https://blog.csdn.net/qq_29924795/article/details/72772251">Java多线程的死锁，活锁，饥饿</a></p>
<h2>可见性</h2>
<p>可见性是指当一个线程修改了某一个共享变量的值时，其他线程是否能够立即知道这个修改。<strong>volatile</strong>关键字并不能真正保证线程安全。它只能确保一个线程修改了数据后，其他线程能够看到这个改动。但当两个线程同时修改某一个数据时，依然会产生冲突。</p>
<h2>线程的生命周期</h2>
<p>Thread中State枚举定义</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">enum</span><span class="w"> </span><span class="n">State</span><span class="p">{</span>
<span class="w">    </span><span class="n">NEW</span><span class="p">,</span>
<span class="w">    </span><span class="n">RUNNABLE</span><span class="p">,</span>
<span class="w">    </span><span class="n">BLOCKED</span><span class="p">,</span>
<span class="w">    </span><span class="n">WAITING</span><span class="p">,</span>
<span class="w">    </span><span class="n">TIME_WAITING</span><span class="p">,</span>
<span class="w">    </span><span class="n">TERMINATED</span>
<span class="p">}</span>
</code></pre></div>

<p><img alt="" src="../Othor_Notes/img/thread_state.jpg"></p>
<blockquote>
<p>NEW状态表示刚刚创建的线程，这种线程还没开始执行。等到线程的start()方法调用时，才表示线程开始执行。当线程执行时，处于RUNNABLE状态，表示线程所需的一切资源都已经准备好了。如果线程在执行过程中遇到了synchronized同步块，就会进入BLOCKED阻塞状态，这时线程就会暂停执行，直到获得请求的锁。WAITING和TIMED_WAITING都表示等待状态，它们的区别是WAITING会进入一个无时间限制的等待，TIMED_WAITING会进行一个有时限的等待。那么等待的线程究竟在等什么呢？一般来说，WAITING的线程正是在等待一些特殊的事件。比如，通过wait()方法等待的线程在等待notify()方法，而通过join()方法等待的线程则会等待目标线程的终止。一旦等到了期望的事件，线程就会再次执行，进入RUNNABLE状态。当线程执行完毕后，则进入TERMINATED状态，表示结束。</p>
</blockquote>
<h2>创建线程的方式</h2>
<ol>
<li>可以继承Thread类</li>
<li>实现Runnable接口</li>
</ol>
<h2>线程终止</h2>
<p>一般来说，线程执行完毕就会结束，无须手工关闭。
stop()方法过于暴力，强行把执行到一半的线程终止，可能会引起一些数据不一致的问题。
Thread.stop()方法在结束线程时，会直接终止线程，并立即释放这个线程所持有的锁，而这些锁恰恰是用来维持对象一致性的。如果此时，写线程写入数据正写到一半，并强行终止，那么对象就会被写坏，同时，由于锁已经被释放，另外一个等待该锁的读线程就顺理成章地读到了这个不一致的对象，悲剧也就此发生。</p>
<h2>线程中断</h2>
<p>在Java中，线程中断是一种重要的线程协作机制。使用stop方法终止线程是不安全的，官方也不推荐使用，我们可以根据线程的中断状态，自行处理中断逻辑。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 它通知目标线程中断，也就是设置中断标志位</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">interrupt</span><span class="p">()</span>
<span class="c1">// 判断线程是否被标记为中断状态</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isInterrupted</span><span class="p">()</span>
<span class="c1">// 判断是否被中断，并清除当前线程的中断状态</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">interrupted</span><span class="p">()</span>
</code></pre></div>

<p><a href="../_drafts1/src/InterruptDemo.java">中断的Demo</a></p>
<h2>wait与notify</h2>
<div class="highlight"><pre><span></span><code><span class="c1">// throws IllegalMonitorStateException</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kd">native</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">notify</span><span class="p">()</span><span class="w"> </span>

<span class="c1">// throws InterruptedException, IllegalMonitorStateException</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">wait</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span>
</code></pre></div>

<p>wait和notify两个方法是Object的方法，不能直接调用这两个方法，你必须在调用前获取object的锁。</p>
<blockquote>
<p>在线程A中，调用了obj.wait()方法，那么线程A就会停止继续执行，转为等待状态。等待到何时结束呢？线程A会一直等到其他线程调用了obj.notify()方法为止。这时，object对象俨然成了多个线程之间的有效通信手段。
如果一个线程调用了object.wait()方法，那么它就会进入object对象的等待队列。这个等待队列中，可能会有多个线程，因为系统运行多个线程同时等待某一个对象。当object.notify()方法被调用时，它就会从这个等待队列中随机选择一个线程，并将其唤醒。这里希望大家注意的是，这个选择是不公平的，并不是先等待的线程就会优先被选择，这个选择完全是随机的。</p>
</blockquote>
<p>生产者与消费者
<img alt="" src="../Othor_Notes/img/生产者与消费者.png"></p>
<div class="highlight"><pre><span></span><code><span class="kd">class</span> <span class="nc">MyBlockingQueue</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span>
<span class="w">   </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxSize</span><span class="p">;</span>
<span class="w">   </span><span class="kd">private</span><span class="w"> </span><span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">storage</span><span class="p">;</span>
<span class="w"> </span>
<span class="w">   </span><span class="kd">public</span><span class="w"> </span><span class="nf">MyBlockingQueue</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="k">this</span><span class="p">.</span><span class="na">maxSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">       </span><span class="n">storage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">   </span><span class="p">}</span>
<span class="w"> </span>
<span class="w">   </span><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">put</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">storage</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">maxSize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">           </span><span class="n">wait</span><span class="p">();</span>
<span class="w">       </span><span class="p">}</span>
<span class="w">       </span><span class="n">storage</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">());</span>
<span class="w">       </span><span class="n">notifyAll</span><span class="p">();</span>
<span class="w">   </span><span class="p">}</span>
<span class="w"> </span>
<span class="w">   </span><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">take</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">storage</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">           </span><span class="n">wait</span><span class="p">();</span>
<span class="w">       </span><span class="p">}</span>
<span class="w">       </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">storage</span><span class="p">.</span><span class="na">remove</span><span class="p">());</span>
<span class="w">       </span><span class="n">notifyAll</span><span class="p">();</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>wait()需要被包在while循环里多次判断wait的执行条件，在上面代码中阻塞队列为空时消费者执行wait操作，释放锁资源。</p>
<blockquote>
<p>wait为什么需要包在while循环里多次判断条件？因为假如你不多次判断，而只判断一次的话会出现阻塞队列为空的时候，消费者去取数据。当有A，B两个消费者都在wait状态，此时生产者添加数据到队列执行notify唤醒消费者，消费者B获取到锁资源然后消费它执行notify，有可能唤醒消费者A执行消费操作就出错了，因为队列是没有数据的。所以执行wait之前需要多此判断条件。</p>
</blockquote>
<h2>join与yeild</h2>
<div class="highlight"><pre><span></span><code><span class="c1">// Thread.yield();</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">native</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">yield</span><span class="p">();</span>
<span class="c1">// join调用的是join(0)</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">join</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">join</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">millis</span><span class="p">)</span>
<span class="w">    </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span>
</code></pre></div>

<p><strong>Thread.yield</strong>当前线程让出cpu，但要注意，让出CPU并不表示当前线程不执行了。当前线程在让出CPU后，还会进行CPU资源的争夺，但是是否能够再次被分配到就不一定了。如果你觉得一个线程不那么重要，或者优先级非常低，而且又害怕它会占用太多的CPU资源，那么可以在适当的时候调用Thread.yield()方法，给予其他重要线程更多的工作机会。
<strong>join</strong>是线程中的方法，查看源码得知它本质上时调用wait方法，比如在主线程中调用线程A的join方法，主线程是释放对象A的锁，然后主线程进入waitting状态，直到线程A执行完释放对象A的锁，主线程才有机会继续执行。</p>
<p><a href="https://www.cnblogs.com/aademeng/articles/10882539.html">Java中join()方法的理解</a></p>
<h2>线程组</h2>
<blockquote>
<p>在java的多线程处理中有线程组ThreadGroup的概念，ThreadGroup是为了方便线程管理出现了，可以统一设定线程组的一些属性，比如setDaemon，设置未处理异常的处理方法，设置统一的安全策略等等；也可以通过线程组方便的获得线程的一些信息。
每一个ThreadGroup都可以包含一组的子线程和一组子线程组，在一个进程中线程组是以树形的方式存在，通常情况下根线程组是system线程组。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。</p>
</blockquote>
<p><a href="https://blog.csdn.net/laomumu1992/article/details/102905585">java线程组（ThreadGroup）</a></p>
<h2>守护线程</h2>
<p><a href="https://blog.csdn.net/qq_41063141/article/details/91939540">java中的用户线程和守护线程</a></p>
<h2>线程优先级</h2>
<blockquote>
<p>线程可以有自己的优先级。优先级高的线程在竞争资源时会更有优势，更<strong>可能</strong>抢占资源。
在Java中，使用1到10表示线程优先级，数字越大则优先级越高。</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="w">   </span><span class="cm">/**</span>
<span class="cm">     * The minimum priority that a thread can have.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MIN_PRIORITY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">   </span><span class="cm">/**</span>
<span class="cm">     * The default priority that is assigned to a thread.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NORM_PRIORITY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * The maximum priority that a thread can have.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MAX_PRIORITY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
</code></pre></div>

<h2>重入锁ReentrantLock</h2>
<blockquote>
<p>重入锁使用ReentrantLock类来实现,可以完全替代关键字synchronized，在JDK 5.0的早期版本中，重入锁的性能远远优于关键字synchronized，但从JDK 6.0开始，JDK在关键字synchronized上做了大量的优化，使得两者的性能差距并不大。开发人员必须手动指定何时加锁，何时释放锁。也正因为这样，重入锁对逻辑控制的灵活性要远远优于关键字synchronized。</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// 获得锁，如果锁已经被占用，则等待</span>
<span class="n">lock</span><span class="p">()</span><span class="err">：</span>
<span class="c1">// 获得锁，但优先响应中断</span>
<span class="n">lockInterruptibly</span><span class="p">()</span><span class="err">：</span>
<span class="c1">// 尝试获得锁，如果成功，则返回true，失败返回false。该方法不等待，立即返回</span>
<span class="n">tryLock</span><span class="p">()</span><span class="err">：</span>
<span class="c1">//在给定时间内尝试获得锁</span>
<span class="n">tryLock</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="w"> </span><span class="n">unit</span><span class="p">)</span><span class="err">：</span>
<span class="c1">//释放锁</span>
<span class="n">unlock</span><span class="p">()</span><span class="err">：</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="kd">class</span> <span class="nc">X</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">m</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">  </span><span class="c1">// block until condition holds</span>
<span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ... method body</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">  </span><span class="c1">// block until condition holds</span>
<span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span>
<span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="c1">// ... method body</span>
<span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span>
<span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>同一个线程多次获得锁，那么在释放锁的时候，也必须释放相同次数。如果释放锁的次数多了，那么会得到一个java.lang.IllegalMonitorStateException异常，反之，如果释放锁的次数少了，那么相当于线程还持有这个锁，因此，其他线程也无法进入临界区。</p>
<h3>公平锁</h3>
<p>ReentrantLock fairLock = new ReentrantLock(true) 构造函数中的参数设置为true</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * 公平锁Demo</span>
<span class="cm"> */</span>
<span class="kd">class</span> <span class="nc">ReentrantLockDemo</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Runnable</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">fairLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">fairLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span>
<span class="w">                </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="mi">1000L</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="o">+</span><span class="s">&quot; 获到锁&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="k">finally</span><span class="p">{</span>
<span class="w">                </span><span class="n">fairLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">    </span>
<span class="w">            </span><span class="p">}</span>

<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ReentrantLockDemo</span><span class="w"> </span><span class="n">reentrantLockDemo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLockDemo</span><span class="p">();</span><span class="w"> </span>
<span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="n">reentrantLockDemo</span><span class="p">,</span><span class="s">&quot;t1&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="n">reentrantLockDemo</span><span class="p">,</span><span class="s">&quot;t2&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">t1</span><span class="p">.</span><span class="na">start</span><span class="p">();</span>
<span class="w">        </span><span class="n">t2</span><span class="p">.</span><span class="na">start</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="p">}</span>
</code></pre></div>

<p>运行结果如下：</p>
<div class="highlight"><pre><span></span><code><span class="n">t1</span><span class="w"> </span><span class="n">获到锁</span>
<span class="n">t2</span><span class="w"> </span><span class="n">获到锁</span>
<span class="n">t1</span><span class="w"> </span><span class="n">获到锁</span>
<span class="n">t2</span><span class="w"> </span><span class="n">获到锁</span>
<span class="p">...</span>
<span class="err">````</span>
<span class="n">可以看到在公平锁下线程交替获取到锁</span><span class="err">，</span><span class="n">显得很公平</span>
<span class="n">ReentrantLock</span><span class="p">.</span><span class="na">lock和ReentrantLock</span><span class="p">.</span><span class="na">unlock类似于synchronized作用</span><span class="err">。</span>
<span class="err">###</span><span class="w"> </span><span class="n">Condition使用</span>
<span class="o">&gt;</span><span class="n">它与wait</span><span class="p">()</span><span class="n">方法和notify</span><span class="p">()</span><span class="n">方法的作用是大致相同的</span><span class="err">。</span><span class="n">但是wait</span><span class="p">()</span><span class="n">方法和notify</span><span class="p">()</span><span class="n">方法是与synchronized关键字合作使用的</span><span class="err">，</span><span class="n">而Condition是与重入锁相关联的</span><span class="err">。</span><span class="n">通过lock接口</span><span class="err">（</span><span class="n">重入锁就实现了这一接口</span><span class="err">）</span><span class="n">的Condition</span><span class="w"> </span><span class="nf">newCondition</span><span class="p">()</span><span class="n">方法可以生成一个与当前重入锁绑定的Condition实例</span><span class="err">。</span><span class="n">利用Condition对象</span><span class="err">，</span><span class="n">我们就可以让线程在合适的时间等待</span><span class="err">，</span><span class="n">或者在某一个特定的时刻得到通知</span><span class="err">，</span><span class="n">继续执行</span><span class="err">。</span>

<span class="n">Condition有几个方法如下</span>
<span class="mf">1.</span><span class="w"> </span><span class="n">await</span><span class="p">()</span><span class="n">方法会使当前线程等待</span><span class="err">，</span><span class="n">同时释放当前锁</span><span class="err">，</span><span class="n">当其他线程中使用signal</span><span class="p">()</span><span class="n">方法或者signalAll</span><span class="p">()</span><span class="n">方法时</span><span class="err">，</span><span class="n">线程会重新获得锁并继续执行</span><span class="err">。</span><span class="n">或者当线程被中断时</span><span class="err">，</span><span class="n">也能跳出等待</span><span class="err">。</span><span class="n">这和Object</span><span class="p">.</span><span class="na">wait</span><span class="p">()</span><span class="n">方法相似</span><span class="err">。</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">awaitUninterruptibly</span><span class="p">()</span><span class="n">方法与await</span><span class="p">()</span><span class="n">方法基本相同</span><span class="err">，</span><span class="n">但是它并不会在等待过程中响应中断</span><span class="err">。</span>

<span class="mf">3.</span><span class="w"> </span><span class="n">singal</span><span class="p">()</span><span class="n">方法用于唤醒一个在等待中的线程</span><span class="err">，</span><span class="n">singalAll</span><span class="p">()</span><span class="n">方法会唤醒所有在等待中的线程</span><span class="err">。</span><span class="n">这和Obejct</span><span class="p">.</span><span class="na">notify</span><span class="p">()</span><span class="n">方法很类似</span><span class="err">。</span>

<span class="err">##</span><span class="w"> </span><span class="n">线程池</span>
<span class="n">为了避免系统频繁地创建和销毁线程</span><span class="err">，</span><span class="n">我们可以让创建的线程复用</span><span class="err">。</span>
<span class="o">-</span><span class="w"> </span><span class="n">线程池的各个参数的含义</span>
<span class="err">```</span><span class="n">java</span>
<span class="c1">// 初始化线程池</span>
<span class="kd">public</span><span class="w"> </span><span class="nf">ThreadPoolExecutor</span><span class="p">(</span>
<span class="w">        </span><span class="c1">// 核心线程数 正式工数量</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// 最大线程数</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 空闲线程存活的时间</span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">keepAliveTime</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 存活时间的单位</span>
<span class="w">        </span><span class="n">TimeUnit</span><span class="w"> </span><span class="n">unit</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 用于存放任务的队列</span>
<span class="w">        </span><span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="w"> </span><span class="n">workQueue</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 创建新线程的工厂</span>
<span class="w">        </span><span class="n">ThreadFactory</span><span class="w"> </span><span class="n">threadFactory</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 处理被拒绝的任务</span>
<span class="w">        </span><span class="n">RejectedExecutionHandler</span><span class="w"> </span><span class="n">handler</span>
<span class="p">)</span>
</code></pre></div>

<p>corePoolSize 是核心线程数，也就是常驻线程池的线程数量，与它对应的是 maxPoolSize，表示线程池最大线程数量，当我们的任务特别多而 corePoolSize 核心线程数无法满足需求的时候，就会向线程池中增加线程，以便应对任务突增的情况。
<img alt="" src="../Othor_Notes/img/线程池执行流程.png">
接下来，我们来具体看下这两个参数所代表的含义，以及线程池中创建线程的时机。如上图所示，当提交任务后，线程池首先会检查当前线程数，如果此时线程数小于核心线程数，比如最开始线程数量为 0，则新建线程并执行任务，随着任务的不断增加，线程数会逐渐增加并达到核心线程数，此时如果仍有任务被不断提交，就会被放入 workQueue 任务队列中，等待核心线程执行完当前任务后重新从 workQueue 中提取正在等待被执行的任务。</p>
<p>此时，假设我们的任务特别的多，已经达到了 workQueue 的容量上限，这时线程池就会启动后备力量，也就是 maxPoolSize 最大线程数，线程池会在 corePoolSize 核心线程数的基础上继续创建线程来执行任务，假设任务被不断提交，线程池会持续创建线程直到线程数达到 maxPoolSize 最大线程数，如果依然有任务被提交，这就超过了线程池的最大处理能力，这个时候线程池就会拒绝这些任务，我们可以看到实际上任务进来之后，线程池会逐一判断 corePoolSize 、workQueue 、maxPoolSize ，如果依然不能满足需求，则会拒绝任务。</p>
<p><img alt="" src="../Othor_Notes/img/线程池执行流程动态图.gif"></p>
<ul>
<li>线程池的阻塞队列
线程池中的这四个主要组成部分最值得我们关注的就是阻塞队列了，如表格所示，不同的线程池会选用不同的阻塞队列。</li>
</ul>
<p><img alt="" src="../Othor_Notes/img/阻塞队列.png"></p>
<p>表格左侧是线程池，右侧为它们对应的阻塞队列，你可以看到 5 种线程池对应了 3 种阻塞队列，我们接下来对它们进行逐一的介绍。</p>
<p><strong>LinkedBlockingQueue</strong>     
对于 FixedThreadPool 和 SingleThreadExector 而言，它们使用的阻塞队列是容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue，可以认为是无界队列。由于 FixedThreadPool 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。这里需要注意，由于线程池的任务队列永远不会放满，所以线程池只会创建核心线程数量的线程，所以此时的最大线程数对线程池来说没有意义，因为并不会触发生成多于核心线程数的线程。</p>
<p><strong>SynchronousQueue</strong>      
第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。</p>
<p>我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。</p>
<p><strong>DelayedWorkQueue</strong>       
第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</p>
<h2>volatile</h2>
<blockquote>
<p>保证可见性，不保证原子性</p>
</blockquote>
<ul>
<li>volatile 和 synchronized 的关系</li>
</ul>
<p>相似性：volatile 可以看作是一个轻量版的 synchronized，比如一个共享变量如果自始至终只被各个线程赋值和读取，而没有其他操作的话，那么就可以用 volatile 来代替 synchronized 或者代替原子变量，足以保证线程安全。实际上，对 volatile 字段的每次读取或写入都类似于“半同步”——读取 volatile 与获取 synchronized 锁有相同的内存语义，而写入 volatile 与释放 synchronized 锁具有相同的语义。</p>
<p>不可代替：但是在更多的情况下，volatile 是不能代替 synchronized 的，volatile 并没有提供原子性和互斥性。</p>
<p>性能方面：volatile 属性的读写操作都是无锁的，正是因为无锁，所以不需要花费时间在获取锁和释放锁上，所以说它是高性能的，比 synchronized 性能更好。</p>
<h2>参考链接</h2>
<p><a href="https://www.zhihu.com/question/19732473">怎样理解阻塞非阻塞与同步异步的区别？</a>
<a href="https://www.cnblogs.com/guanghe/p/9206635.html">并发之原子性、可见性、有序性</a>
<a href="https://blog.csdn.net/fan2012huan/article/details/51781443">Java多线程之临界区、ThreadLocal</a>
<a href="">实战java高并发程序设计</a>
<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析</a>
<a href="https://www.cnblogs.com/soaringEveryday/p/4418604.html">Java多线程共享变量控制</a></p>
<h2>JMM(java内存模型)</h2>
<p>重排序，原子性，内存可见性</p>
<h2>面试</h2>
<ul>
<li>实现runnable接口的3个好处</li>
<li>Runnable 与 Thread 类的解耦，Runnable负责执行的内容，Thread 类负责线程启动和属性设置等内容，权责分明。</li>
<li>Runnable可以结合线程池一起使用</li>
<li>Java 语言不支持双继承，如果我们的类一旦继承了 Thread 类，那么它后续就没有办法再继承其他的类，这样一来，如果未来这个类需要继承其他类实现一些功能上的拓展，它就没有办法做到了，相当于限制了代码未来的可拓展性。</li>
<li><a href="https://blog.csdn.net/vking_wang/article/details/9982709">volatile的适用场景</a></li>
</ul></div>
    <footer>
<p class="meta">
  <span class="byline author vcard">
    Posted by <span class="fn">
        manymore13
    </span>
  </span>
<time datetime="2020-01-05T14:00:00+08:00" pubdate>Sun 05 January 2020</time>  <span class="categories">
    <a class='category' href='/category/java_notes.html'>Java_Notes</a>
  </span>
</p><div class="sharing">
</div>    </footer>
  </article>

</div>
<aside class="sidebar">
  <section>
    <h1>Recent Posts</h1>
    <ul id="recent_posts">
      <li class="post">
          <a href="/ji-zhu-wen-zhang-sou-ji.html">技术文章搜集</a>
      </li>
      <li class="post">
          <a href="/gu-zhi-gong-ju.html">估值工具</a>
      </li>
      <li class="post">
          <a href="/pa-chong-bi-ji.html">爬虫笔记</a>
      </li>
      <li class="post">
          <a href="/cai-wu-bao-biao.html">财务报表</a>
      </li>
      <li class="post">
          <a href="/tou-zi-ji-si-lu.html">投资集思录</a>
      </li>
    </ul>
  </section>
  <section>
      
    <h1>Categories</h1>
    <ul id="recent_posts">
        <li><a href="/category/android_notes.html">Android_Notes</a></li>
        <li><a href="/category/financial_notes.html">Financial_Notes</a></li>
        <li><a href="/category/gu-zhi-gong-ju.html">估值工具</a></li>
        <li><a href="/category/java_notes.html">Java_Notes</a></li>
        <li><a href="/category/ji-suan-ji.html">计算机</a></li>
        <li><a href="/category/jie-zhi.html">价值</a></li>
        <li><a href="/category/life_notes.html">Life_Notes</a></li>
        <li><a href="/category/python_notes.html">Python_Notes</a></li>
    </ul>
  </section>
 

  <section>
  <h1>Tags</h1>
    <a href="/tag/android.html">Android</a>,    <a href="/tag/sou-ji.html">搜集</a>,    <a href="/tag/gu-zhi.html">估值</a>,    <a href="/tag/gong-ju.html">工具</a>,    <a href="/tag/li-cai.html">理财</a>,    <a href="/tag/jin-rong.html">金融</a>,    <a href="/tag/uml.html">UML</a>,    <a href="/tag/kai-yuan.html">开源</a>,    <a href="/tag/du-shu.html">读书</a>,    <a href="/tag/xie-cheng.html">协程</a>  </section>


    <section>
        <h1>Social</h1>
        <ul>
            <li><a href="#" target="_blank">You can add links in your config file</a></li>
            <li><a href="#" target="_blank">Another social link</a></li>
        </ul>
    </section>
    <section>
        <h1>Blogroll</h1>
        <ul>
            <li><a href="https://getpelican.com/" target="_blank">Pelican</a></li>
            <li><a href="https://www.python.org/" target="_blank">Python.org</a></li>
            <li><a href="https://palletsprojects.com/p/jinja/" target="_blank">Jinja2</a></li>
            <li><a href="#" target="_blank">You can modify those links in your config file</a></li>
        </ul>
    </section>

</aside>    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy;  2020&ndash;2023  manymore13 &mdash;
  <span class="credit">Powered by <a href="http://getpelican.com">Pelican</a></span>
</p></footer>
  <script src="/theme/js/modernizr-2.0.js"></script>
  <script src="/theme/js/ender.js"></script>
  <script src="/theme/js/octopress.js" type="text/javascript"></script>
</body>
</html>