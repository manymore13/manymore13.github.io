<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>manymore13&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="主要分享技术">
<meta property="og:type" content="website">
<meta property="og:title" content="manymore13&#39;s blog">
<meta property="og:url" content="https://manymore13.github.io/index.html">
<meta property="og:site_name" content="manymore13&#39;s blog">
<meta property="og:description" content="主要分享技术">
<meta property="og:locale">
<meta property="article:author" content="manymore13">
<meta property="article:tag" content="技术,投资">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="manymore13's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">manymore13&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">纸上得来终觉浅，绝知此事要躬行</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://manymore13.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-NIO笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/18/NIO%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2024-02-18T07:38:41.138Z" itemprop="datePublished">2024-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/18/NIO%E7%AC%94%E8%AE%B0/">NIO笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="NIO笔记"><a href="#NIO笔记" class="headerlink" title="NIO笔记"></a>NIO笔记</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>输入流就是把数据（键盘输入、鼠标、扫描仪等等外设设备）读入到内存（程序）中，输出流就是把内存（程序）中的数据输出到外设或其他地方，从文件角度简单总结就是，输入流就是读数据，输出流就是写数据。在这个过程中，始终把内存作为参考点。</p>
<h2 id="java-NIO基本介绍"><a href="#java-NIO基本介绍" class="headerlink" title="java NIO基本介绍"></a>java NIO基本介绍</h2><ol>
<li><p>Java NIO 全称 java non-blocking IO，是指 JDK 提供的新 API。<br>从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO(即 New IO)，是<strong>同步非阻塞</strong>的</p>
</li>
<li><p>NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器) </p>
</li>
<li><p>NIO是 面向缓冲区 ，或者面向 块 编程的。数据读取到一个它稍后处理的缓冲区，<br>需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络</p>
</li>
</ol>
<h2 id="NIO-和-BIO-的比较"><a href="#NIO-和-BIO-的比较" class="headerlink" title="NIO 和 BIO 的比较"></a>NIO 和 BIO 的比较</h2><ol>
<li>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I&#x2F;O 的效率比流 I&#x2F;O 高很多</li>
<li>BIO 是阻塞的，NIO 则是非阻塞的</li>
<li>BIO基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</li>
</ol>
<h2 id="NIO-三大核心原理示意图"><a href="#NIO-三大核心原理示意图" class="headerlink" title="NIO 三大核心原理示意图"></a>NIO 三大核心原理示意图</h2><p><img src="/../img/nioylt.png" alt="nio原理图"></p>
<ol>
<li>每个channel 都会对应一个Buffer</li>
<li>Selector 对应一个线程， 一个线程对应多个channel(连接)</li>
<li>该图反应了有三个channel 注册到 该selector &#x2F;&#x2F;程序</li>
<li>程序切换到哪个channel 是有事件决定的, Event 就是一个重要的概念</li>
<li>Selector 会根据不同的事件，在各个通道上切换</li>
<li>Buffer 就是一个内存块 ， 底层是有一个数组</li>
<li>数据的读取写入是通过Buffer, 这个和BIO , BIO 中要么是输入流，或者是输出流, 不能双向，但是NIO的Buffer 是可以读也可以写, 需要 flip 方法切换</li>
<li>channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ， 底层的操作系统通道就是双向的.</li>
</ol>
<p></p>
<h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h3><p>缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，<br>缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<br>Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Capacity</td>
<td>容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变</td>
</tr>
<tr>
<td>Limit</td>
<td>表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作。且极限是可以修改的</td>
</tr>
<tr>
<td>Position</td>
<td>位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变改值，为下次读写作准备</td>
</tr>
<tr>
<td>Mark</td>
<td>标记</td>
</tr>
</tbody></table>
<h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><ol>
<li>NIO的通道类似于流，但有些区别如下：</li>
</ol>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
</ul>
<p> <br>2. BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)是双向的，可以读操作，也可以写操作。<br>3. 常用的 Channel 类有：FileChannel、DatagramChannel、ServerSocketChannel 和 SocketChannel。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】<br>4. FileChannel 用于文件的数据读写，DatagramChannel 用于 UDP 的数据读写，ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写。</p>
<h4 id="FileChannel-类"><a href="#FileChannel-类" class="headerlink" title="FileChannel 类"></a>FileChannel 类</h4><ul>
<li>FileChannel主要用来对本地文件进行 IO 操作，常见的方法有</li>
<li>public int read(ByteBuffer dst) ，从通道读取数据并放到缓冲区中</li>
<li>public int write(ByteBuffer src) ，把缓冲区的数据写到通道中</li>
<li>public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道中复制数据到当前通道</li>
<li>public long transferTo(long position, long count, WritableByteChannel target)，把数据从当前通道复制给目标通道</li>
</ul>
<h4 id="利用nio拷贝文件"><a href="#利用nio拷贝文件" class="headerlink" title="利用nio拷贝文件"></a>利用nio拷贝文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileChannel01</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileChannel02</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">    <span class="comment">//循环读取</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里有一个重要的操作，一定不要忘了</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         public final Buffer clear() &#123;</span></span><br><span class="line"><span class="comment">            position = 0;</span></span><br><span class="line"><span class="comment">            limit = capacity;</span></span><br><span class="line"><span class="comment">            mark = -1;</span></span><br><span class="line"><span class="comment">            return this;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        byteBuffer.clear(); <span class="comment">//清空buffer</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fileChannel01.read(byteBuffer);</span><br><span class="line">        System.out.println(<span class="string">&quot;read =&quot;</span> + read);</span><br><span class="line">        <span class="comment">//表示读完</span></span><br><span class="line">        <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将buffer 中的数据写入到 fileChannel02 -- 2.txt</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        fileChannel02.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭相关的流</span></span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拷贝文件transferFrom-方法"><a href="#拷贝文件transferFrom-方法" class="headerlink" title="拷贝文件transferFrom 方法"></a>拷贝文件transferFrom 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建相关流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\a.jpg&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\a2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取各个流对应的filechannel</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">sourceCh</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">destCh</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用transferForm完成拷贝</span></span><br><span class="line">        destCh.transferFrom(sourceCh,<span class="number">0</span>,sourceCh.size());</span><br><span class="line">        <span class="comment">//关闭相关通道和流</span></span><br><span class="line">        sourceCh.close();</span><br><span class="line">        destCh.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2024/02/18/NIO%E7%AC%94%E8%AE%B0/" data-id="clsr95v000003kcwz13gr39k7" data-title="NIO笔记" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/18/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-02-18T07:09:16.139Z" itemprop="datePublished">2024-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/18/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2024/02/18/hello-world/" data-id="clsr95v020005kcwz2bh46r5i" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Android面试题整理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/07/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2020-02-07T10:23:53.000Z" itemprop="datePublished">2020-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/07/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">Android面试题整理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Android-Handler消息机制"><a href="#Android-Handler消息机制" class="headerlink" title="Android Handler消息机制"></a>Android Handler消息机制</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c74b64a6fb9a049be5e22fc#heading-17">参考链接</a></p>
</blockquote>
<ol>
<li>Handler 的背后有 Looper、MessageQueue 支撑，Looper 负责消息分发，MessageQueue 负责消息管理；</li>
<li>在创建 Handler 之前一定需要先创建 Looper；</li>
<li>Looper 有退出的功能，但是主线程的 Looper 不允许退出；</li>
<li>异步线程的 Looper 需要自己调用 Looper.myLooper().quit();  退出；</li>
<li>Runnable 被封装进了 Message，可以说是一个特殊的 Message；</li>
<li>Handler.handleMessage() 所在的线程是 Looper.loop() 方法被调用的线程，也可以说成 Looper 所在的线程，并不是创建 Handler 的线程；</li>
<li>使用内部类的方式使用 Handler 可能会导致内存泄露，即便在 Activity.onDestroy 里移除延时消息，必须要写成静态内部类；</li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/34652589/answer/90344494">Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</a> 阻塞线程，处于休眠状态，但不耗用CPU资源</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gs344937933/article/details/89815855">Android卡顿优化–卡顿检测</a> 卡顿检测工具里面有用到Looper</li>
</ol>
<p>主线程的死循环一直运行是不是特别消耗CPU资源呢？ 其实不然，这里就涉及到Linux pipe&#x2F;epoll机制，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，详情见Android消息机制1-Handler(Java层)，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I&#x2F;O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
<h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5951ebdd2a7e">深入理解事件分发 ViewGroup.mFirstTouchTarget的设计</a></p>
<blockquote>
<p>mFirstTouchTarget的作用是什么，记录后续事件派发的目标</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jymblog/p/12178527.html">你真的看懂Android事件分发了吗？</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本源码来自 api 28,不同版本略有不同。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步：处理拦截</span></span><br><span class="line">   <span class="type">boolean</span> intercepted;  </span><br><span class="line">     <span class="comment">// 注意这个条件，后者代表着有子view消费事件。后面会讲</span></span><br><span class="line">   <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 子view调用了parent.requestDisallowInterceptTouchEvent干预父布局的拦截，不让它爸拦截它</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">             intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">             ev.setAction(action); </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             intercepted = <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//既不是DOWN事件，mFirstTouchTarget还是null，这种情况挺常见：如果ViewGroup的所有的子View都不消费				//事件，那么当ACTION_MOVE等非DOWN事件到来时，都被拦截了。</span></span><br><span class="line">         intercepted = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，分发ACTION_DOWN</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">alreadyDispatchedToNewTouchTarget</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//注意这个变量,会用到</span></span><br><span class="line">   <span class="comment">// 不拦截才会分发它，如果拦截了，就不分发ACTION_DOWN了</span></span><br><span class="line">    <span class="keyword">if</span> (!intercepted) &#123;</span><br><span class="line">        <span class="comment">//处理DOWN事件，捕获第一个被触摸的mFirstTouchTarget，mFirstTouchTarget很重要，</span></span><br><span class="line">        保存了消费了ACTION_DOWN事件的子view</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(ev.getAction == MotionEvent.ACTION_DOWN)</span> &#123;</span><br><span class="line">            <span class="comment">//遍历所有子view(看源码知子View是按照Z轴排好序的)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">//子view如果：1.不包含事件坐标 2. 在动画  则跳过</span></span><br><span class="line">                <span class="keyword">if</span> (!isTransformedTouchPointInView() || !canViewReceivePointerEvents()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将事件传递给子view的坐标空间，并且判断该子view是否消费这个触摸事件（分发Down事件）</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent()) &#123;</span><br><span class="line">                    <span class="comment">//将该view加入头节点，并且赋值给mFirstTouchTarget</span></span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步：分发非DOWN事件</span></span><br><span class="line">        <span class="comment">//如果没有子view捕获ACTION_DOWN，则交给本ViewGroup处理这个事件。我们看到，这里并没有判断是否拦截，</span></span><br><span class="line">        <span class="comment">//为什么呢？因为如果拦截的话，上面的代码不会执行，就会导致mFirstTouchTarget== null，于是就走下面第一         				//个条件里的逻辑了</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>.dispatchTouchEvent(ev); <span class="comment">//调用View的dispatchTouchEvent，也就是自己处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历touchTargets链表，依次分发事件</span></span><br><span class="line">            <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget) &#123;</span><br><span class="line">                  handled = <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  	<span class="keyword">if</span> (dispatchTransformedTouchEvent()) &#123;</span><br><span class="line">                      handled = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  target = target.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理ACTION_UP和CANCEL，手指抬起来以后相关变量重置</span></span><br><span class="line">        <span class="keyword">if</span> (ev.getAction == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">            reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><h2 id="Android和java基本面试题"><a href="#Android和java基本面试题" class="headerlink" title="Android和java基本面试题"></a>Android和java基本面试题</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhu592665411/article/details/80617081">LRU算法及编码实现LRU策略缓存</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39192827/article/details/85611873">Java：强引用，软引用，弱引用和虚引用</a></p>
<blockquote>
<p><strong>强引用</strong>：必不可少的物品，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。<br><strong>软引用</strong>:用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，<em><strong>只有在内存不足的时候JVM才会回收该对象</strong></em>。<br><strong>弱引用</strong>:用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。</p>
</blockquote>
</li>
<li><p>断点续传的实现</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuanblog/p/4441017.html">Java中HashMap的实现原理</a>  </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60702023">ThreadLoacal用法以及原理</a></p>
<blockquote>
<p>ThreadLocal的实现原理是，在每个线程中维护一个Map，键是ThreadLocal类型，值是Object类型。当想获取ThreadLocal的值时，就从当前线程中拿出Map，然后在把ThreadLocal本身作为键从Map中拿出值返回。  </p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010647035/article/details/79770534">Java线程之如何分析死锁及避免死锁</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903917428424717">Java线程池工作原理浅析</a><br>关键类：ThreadPoolExecutor</p>
</li>
<li><p>Binder 跨进程通信机制<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903589635162126">写给 Android 应用工程师的 Binder 原理剖析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30379689/article/details/79451596">Android进阶——Android跨进程通讯机制之Binder、IBinder、Parcel、AIDL</a></p>
</li>
</ul>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhanglei93/p/6590609.html">Java虚拟机工作原理</a></p>
<h2 id="第三方库源码分析"><a href="#第三方库源码分析" class="headerlink" title="第三方库源码分析"></a>第三方库源码分析</h2><h3 id="OKHTTP"><a href="#OKHTTP" class="headerlink" title="OKHTTP"></a>OKHTTP</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904087788453896">面试官：听说你熟悉OkHttp原理？</a><br>OKHttpClient,RealCall,Dispatcher,AsynCall</p>
<ol>
<li>请求流程</li>
<li>分发器(Dispatcher)</li>
<li>拦截器<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ba6e219a0af6">OkHttp之拦截器</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5e11962afed2">Android okhttp 刷新token</a></li>
<li>缓存</li>
<li>连接池<br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/tangjiean/article/details/51729371">okhttp连接池复用机制</a></li>
<li>okio<br><a target="_blank" rel="noopener" href="https://square.github.io/okio/">官网</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zoudifei/article/details/51232711">深入理解okio的优化思想</a><br>sources和sinks</li>
</ol>
<h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7061714acabe">retrofit源码解析–retrofit创建方法(builder、baseurl、converter…)</a></p>
<h3 id="Rxjava"><a href="#Rxjava" class="headerlink" title="Rxjava"></a>Rxjava</h3><p><a target="_blank" rel="noopener" href="https://gank.io/post/560e15be2dca930e00da1083">给 Android 开发者的 RxJava 详解</a></p>
<ol>
<li>订阅流程<img src="./img/rxjava_subscribe.png" width="60%" />
从下游一层一层往上游订阅，订阅的时候会调用subscribeActual方法，而在这个方法里订阅上游，每订阅一层会创建一个Observer
，而Observer中持有下游的Observer，当订阅到最顶层的时候，事件创建者开始向下游分发事件比如onNext，onSuccess,往下游传递事件少不了每一层自己创建的Observer。
测试代码如下：
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mySingleObserver = <span class="keyword">object</span> : SingleObserver&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(t: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;------<span class="variable">$t</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubscribe</span><span class="params">(d: <span class="type">Disposable</span>?)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;我被订阅了&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Throwable</span>?)</span></span> &#123;</span><br><span class="line">            e?.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Single.just(<span class="number">1</span>)</span><br><span class="line">            .map(<span class="keyword">object</span> : io.reactivex.rxjava3.functions.Function&lt;<span class="built_in">Int</span>, String&gt; &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(t: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;---<span class="variable">$t</span>&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(mySingleObserver)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
首先看一下代码这里面有几个对象，我们分解一下会更容易理解些</li>
<li>Single.just(1)实际上是创建了SingleJust对象，SingleJust继承于Single。</li>
<li>SingleJust.map()创建了SingleMap对象，SingleMap同样是继承于Single</li>
<li>上面代码最终可以这么看 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SingleJust.SingleMap.subscribe(mySingleObserver)</span><br></pre></td></tr></table></figure></li>
<li>subscribe方法是SingleMap对象的方法，也是Single类中的方法</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> void subscribe(<span class="meta">@NonNull</span> SingleObserver&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        Objects.requireNonNull(observer, <span class="string">&quot;observer is null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">        Objects.requireNonNull(observer, <span class="string">&quot;The RxJavaPlugins.onSubscribe hook returned a null SingleObserver. Please check the handler provided to RxJavaPlugins.setOnSingleSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 接着上面步骤来，它其实调用的SingleMap类的subscribeActual方法</span></span><br><span class="line">            subscribeActual(observer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            NullPointerException npe = new NullPointerException(<span class="string">&quot;subscribeActual failed&quot;</span>);</span><br><span class="line">            npe.initCause(ex);</span><br><span class="line">            <span class="keyword">throw</span> npe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>SingleMap源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SingleMap</span>&lt;T, R&gt; <span class="keyword">extends</span> <span class="title class_">Single</span>&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> SingleSource&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">R</span>&gt; mapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SingleMap</span><span class="params">(SingleSource&lt;? extends T&gt; source, Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.source = source;</span><br><span class="line">        <span class="built_in">this</span>.mapper = mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面订阅的时候，实际上调用的就是这个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">subscribeActual</span><span class="params">(<span class="keyword">final</span> SingleObserver&lt;? <span class="built_in">super</span> R&gt; t)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个source是SingleJust对象，也就是SingleMap的上游</span></span><br><span class="line">        source.subscribe(<span class="keyword">new</span> <span class="title class_">MapSingleObserver</span>&lt;T, R&gt;(t, mapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MapSingleObserver</span>&lt;T, R&gt; <span class="keyword">implements</span> <span class="title class_">SingleObserver</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SingleObserver&lt;? <span class="built_in">super</span> R&gt; t;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">R</span>&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapSingleObserver(SingleObserver&lt;? <span class="built_in">super</span> R&gt; t, Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">R</span>&gt; mapper) &#123;</span><br><span class="line">            <span class="built_in">this</span>.t = t;</span><br><span class="line">            <span class="built_in">this</span>.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">            t.onSubscribe(d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(T value)</span> &#123;</span><br><span class="line">            R v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                v = Objects.requireNonNull(mapper.apply(value), <span class="string">&quot;The mapper function returned a null value.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(e);</span><br><span class="line">                onError(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            t.onSuccess(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">            t.onError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.是哪个对象在什么时候创建了子线程，是一种怎样的方式创建的？<br>2.子线程又是如何启动的？<br>3.上游事件是怎么跑到子线程里执行的？<br>4.多次用 subscribeOn 指定上游线程为什么只有第一次有效 ?<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3dd582bb10cc">RxJava 是如何实现线程切换的（上）</a></p>
<h3 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h3><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/guolin_blog/article/details/28863651">Android DiskLruCache完全解析，硬盘缓存的最佳方案</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lmj623565791/article/details/47251585">Android DiskLruCache 源码解析 硬盘缓存的绝佳方案</a></li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuxingrong666/article/details/83869161">HTTPS的数字证书验证原理</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/daxueba-ITdaren/p/6495468.html">证书锁定Certificate Pinning技术</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7158568e4867">SSL&#x2F;TLS 握手过程详解</a></p>
<h2 id="Android架构"><a href="#Android架构" class="headerlink" title="Android架构"></a>Android架构</h2><p><a href="">Android 组件化与插件化</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1b1d77f58e84">Android彻底组件化方案实践</a></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_17766199/category_9270906.html">Android单元测试</a></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b50b017f265da0f7b2f649c">Android 性能优化最佳实践</a></p>
<h3 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h3><ol>
<li>重绘制</li>
<li>include、merge和ViewStub</li>
<li>复杂界面可选择ConstraintLayout，可有效减少层级</li>
<li>View的绘制频率保证60fps是最佳的， onDraw方法中不要做耗时的任务，也不做过多的循环操作，onDraw()中不要创建新的局部对象。</li>
</ol>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><ol>
<li>内存泄露：单例&#x2F;静态变量造成的内存泄漏，匿名内部类&#x2F;非静态内部类</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/sucese/android-open-framework-analysis">Android Open Framework Analysis</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016117569">分享一份非常强势的Android面试题</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jinguangyue/Android-Advanced-Interview">Android-Advanced-Interview</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ee48103f265da76d53c2676">最新 Android 面试点梳理，我收藏了你呢？</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2020/02/07/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" data-id="clsr95uzr0000kcwzc16l9zbr" data-title="Android面试题整理" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-%E9%9D%A2%E8%AF%95/" rel="tag">Android,面试</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-%E9%9D%A2%E8%AF%95/" rel="tag">Android,面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android-%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">Android,面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/02/18/NIO%E7%AC%94%E8%AE%B0/">NIO笔记</a>
          </li>
        
          <li>
            <a href="/2024/02/18/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/02/07/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">Android面试题整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 manymore13<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>