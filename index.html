<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>manymore13&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="分享技术与生活">
<meta property="og:type" content="website">
<meta property="og:title" content="manymore13&#39;s blog">
<meta property="og:url" content="https://manymore13.github.io/index.html">
<meta property="og:site_name" content="manymore13&#39;s blog">
<meta property="og:description" content="分享技术与生活">
<meta property="og:locale">
<meta property="article:author" content="manymore13">
<meta property="article:tag" content="技术,投资">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="manymore13's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">manymore13&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">纸上得来终觉浅，绝知此事要躬行</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://manymore13.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-NIO笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/18/NIO%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2024-02-18T07:38:41.138Z" itemprop="datePublished">2024-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/18/NIO%E7%AC%94%E8%AE%B0/">NIO笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="NIO笔记"><a href="#NIO笔记" class="headerlink" title="NIO笔记"></a>NIO笔记</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>输入流就是把数据（键盘输入、鼠标、扫描仪等等外设设备）读入到内存（程序）中，输出流就是把内存（程序）中的数据输出到外设或其他地方，从文件角度简单总结就是，输入流就是读数据，输出流就是写数据。在这个过程中，始终把内存作为参考点。</p>
<h2 id="java-NIO基本介绍"><a href="#java-NIO基本介绍" class="headerlink" title="java NIO基本介绍"></a>java NIO基本介绍</h2><ol>
<li><p>Java NIO 全称 java non-blocking IO，是指 JDK 提供的新 API。<br>从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO(即 New IO)，是<strong>同步非阻塞</strong>的</p>
</li>
<li><p>NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器) </p>
</li>
<li><p>NIO是 面向缓冲区 ，或者面向 块 编程的。数据读取到一个它稍后处理的缓冲区，<br>需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络</p>
</li>
</ol>
<h2 id="NIO-和-BIO-的比较"><a href="#NIO-和-BIO-的比较" class="headerlink" title="NIO 和 BIO 的比较"></a>NIO 和 BIO 的比较</h2><ol>
<li>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I&#x2F;O 的效率比流 I&#x2F;O 高很多</li>
<li>BIO 是阻塞的，NIO 则是非阻塞的</li>
<li>BIO基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</li>
</ol>
<h2 id="NIO-三大核心原理示意图"><a href="#NIO-三大核心原理示意图" class="headerlink" title="NIO 三大核心原理示意图"></a>NIO 三大核心原理示意图</h2><p><img src="/../img/nioylt.png" alt="nio原理图"></p>
<ol>
<li>每个channel 都会对应一个Buffer</li>
<li>Selector 对应一个线程， 一个线程对应多个channel(连接)</li>
<li>该图反应了有三个channel 注册到 该selector &#x2F;&#x2F;程序</li>
<li>程序切换到哪个channel 是有事件决定的, Event 就是一个重要的概念</li>
<li>Selector 会根据不同的事件，在各个通道上切换</li>
<li>Buffer 就是一个内存块 ， 底层是有一个数组</li>
<li>数据的读取写入是通过Buffer, 这个和BIO , BIO 中要么是输入流，或者是输出流, 不能双向，但是NIO的Buffer 是可以读也可以写, 需要 flip 方法切换</li>
<li>channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ， 底层的操作系统通道就是双向的.</li>
</ol>
<p></p>
<h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h3><p>缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，<br>缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<br>Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Capacity</td>
<td>容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变</td>
</tr>
<tr>
<td>Limit</td>
<td>表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作。且极限是可以修改的</td>
</tr>
<tr>
<td>Position</td>
<td>位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变改值，为下次读写作准备</td>
</tr>
<tr>
<td>Mark</td>
<td>标记</td>
</tr>
</tbody></table>
<h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><ol>
<li>NIO的通道类似于流，但有些区别如下：</li>
</ol>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
</ul>
<p> <br>2. BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)是双向的，可以读操作，也可以写操作。<br>3. 常用的 Channel 类有：FileChannel、DatagramChannel、ServerSocketChannel 和 SocketChannel。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】<br>4. FileChannel 用于文件的数据读写，DatagramChannel 用于 UDP 的数据读写，ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写。</p>
<h4 id="FileChannel-类"><a href="#FileChannel-类" class="headerlink" title="FileChannel 类"></a>FileChannel 类</h4><ul>
<li>FileChannel主要用来对本地文件进行 IO 操作，常见的方法有</li>
<li>public int read(ByteBuffer dst) ，从通道读取数据并放到缓冲区中</li>
<li>public int write(ByteBuffer src) ，把缓冲区的数据写到通道中</li>
<li>public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道中复制数据到当前通道</li>
<li>public long transferTo(long position, long count, WritableByteChannel target)，把数据从当前通道复制给目标通道</li>
</ul>
<h4 id="利用nio拷贝文件"><a href="#利用nio拷贝文件" class="headerlink" title="利用nio拷贝文件"></a>利用nio拷贝文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileChannel01</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileChannel02</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">    <span class="comment">//循环读取</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里有一个重要的操作，一定不要忘了</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         public final Buffer clear() &#123;</span></span><br><span class="line"><span class="comment">            position = 0;</span></span><br><span class="line"><span class="comment">            limit = capacity;</span></span><br><span class="line"><span class="comment">            mark = -1;</span></span><br><span class="line"><span class="comment">            return this;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        byteBuffer.clear(); <span class="comment">//清空buffer</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fileChannel01.read(byteBuffer);</span><br><span class="line">        System.out.println(<span class="string">&quot;read =&quot;</span> + read);</span><br><span class="line">        <span class="comment">//表示读完</span></span><br><span class="line">        <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将buffer 中的数据写入到 fileChannel02 -- 2.txt</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        fileChannel02.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭相关的流</span></span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拷贝文件transferFrom-方法"><a href="#拷贝文件transferFrom-方法" class="headerlink" title="拷贝文件transferFrom 方法"></a>拷贝文件transferFrom 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建相关流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\a.jpg&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\a2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取各个流对应的filechannel</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">sourceCh</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">destCh</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用transferForm完成拷贝</span></span><br><span class="line">        destCh.transferFrom(sourceCh,<span class="number">0</span>,sourceCh.size());</span><br><span class="line">        <span class="comment">//关闭相关通道和流</span></span><br><span class="line">        sourceCh.close();</span><br><span class="line">        destCh.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2024/02/18/NIO%E7%AC%94%E8%AE%B0/" data-id="clsrcp7g800053gwzfnifdig5" data-title="NIO笔记" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/18/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-02-18T07:09:16.139Z" itemprop="datePublished">2024-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/18/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2024/02/18/hello-world/" data-id="clsrcp7g600023gwz0uf07cfy" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-爬虫专题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/15/%E7%88%AC%E8%99%AB%E4%B8%93%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-05-15T08:23:43.000Z" itemprop="datePublished">2023-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/15/%E7%88%AC%E8%99%AB%E4%B8%93%E9%A2%98/">爬虫笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h2><p>Requests是一个优雅而简单的Python HTTP库。</p>
<p>具体用法参考 <a target="_blank" rel="noopener" href="https://requests.readthedocs.io/en/latest/">Home-page</a></p>
<hr>
<h2 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h2><p>Scrapy是一个快速的高级网页抓取和网页抓取框架，用于抓取网站并从页面中提取结构化数据。它广泛用于数据挖掘到监控和自动化测试领域。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.scrapy.org/">scrapy官网</a></li>
<li><a target="_blank" rel="noopener" href="https://scrapy-cookbook.readthedocs.io/zh_CN/latest/index.html">scrapy-cookbook</a></li>
</ul>
<hr>
<h2 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h2><p><code>Selenium</code>是一个自动化测试工具，支持各种浏览器，包括Chrome、Safari、Firefox 等主流界面式浏览器。简单理解，Selenium可以模拟操作浏览器，对一些需要动态加载的页面，不需要我们执行JavaScript等操作，即可自动加载完成后的页面。</p>
<hr>
<h3 id="安装Selenium"><a href="#安装Selenium" class="headerlink" title="安装Selenium"></a>安装Selenium</h3><p>直接使用pip安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>
<p>我安装的版本是 Version: 4.9.0</p>
<ul>
<li>安装Selenium之后，还需要下载对应的浏览器驱动</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><a target="_blank" rel="noopener" href="https://sites.google.com/a/chromium.org/chromedriver/home">Chrome driver</a></th>
<th align="center"><a target="_blank" rel="noopener" href="https://github.com/mozilla/geckodriver/releases">Firefox driver</a></th>
<th align="center"><a target="_blank" rel="noopener" href="https://github.com/mozilla/geckodriver/releases">IE driver</a></th>
<th align="center"><a target="_blank" rel="noopener" href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver">Edge driver</a></th>
</tr>
</thead>
</table>
<ul>
<li>检查是否安装成功</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver = webdriver.Edge()</span><br><span class="line">driver.get(<span class="string">&quot;https://www.so.com/&quot;</span>)</span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;按任意键退出&quot;</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>
<p>若能正常打开浏览器，则安装成功</p>
<h3 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">id</span>=<span class="string">&quot;vegetables&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;potatoes&quot;</span>&gt;</span>…</span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;onions&quot;</span>&gt;</span>…</span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;tomatoes&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Tomato is a Vegetable<span class="tag">&lt;/<span class="name">span</span>&gt;</span>…</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;fruits&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;bananas&quot;</span>&gt;</span>…</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;apples&quot;</span>&gt;</span>…</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;tomatoes&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Tomato is a Fruit<span class="tag">&lt;/<span class="name">span</span>&gt;</span>…</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上面html为例，我们来定位元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过class name定位</span></span><br><span class="line">vegetable = driver.find_element(By.CLASS_NAME, <span class="string">&quot;tomatoes&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过id定位水果元素，再通过水果元素定位西红柿元素，这种嵌套定位效率不是最好的</span></span><br><span class="line">fruits = driver.find_element(By.ID, <span class="string">&quot;fruits&quot;</span>)</span><br><span class="line">fruit = fruits.find_element(By.CLASS_NAME,<span class="string">&quot;tomatoes&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过CSS 选择器定位元素</span></span><br><span class="line">fruit = driver.find_element(By.CSS_SELECTOR,<span class="string">&quot;#fruits .tomatoes&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过标签名定位元素，这里是获取所有标签li   </span></span><br><span class="line">plants = driver.find_elements(By.TAG_NAME, <span class="string">&quot;li&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外一个实例: 打开百度，然后搜索</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我的是微软Edge浏览器</span></span><br><span class="line">driver = webdriver.Edge()</span><br><span class="line"><span class="comment"># 加载网页.</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com/&quot;</span>)</span><br><span class="line"></span><br><span class="line">title = driver.title</span><br><span class="line"><span class="keyword">assert</span> title == <span class="string">&quot;百度一下，你就知道&quot;</span></span><br><span class="line"></span><br><span class="line">driver.implicitly_wait(<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 获取输入框元素</span></span><br><span class="line">text_box = driver.find_element(by=By.ID, value=<span class="string">&quot;kw&quot;</span>)</span><br><span class="line"><span class="comment"># 获取提交按钮元素</span></span><br><span class="line">submit_button = driver.find_element(by=By.CSS_SELECTOR, value=<span class="string">&quot;#su&quot;</span>)</span><br><span class="line"><span class="comment"># 输入关键词</span></span><br><span class="line">text_box.send_keys(<span class="string">&quot;Selenium&quot;</span>)</span><br><span class="line"><span class="comment"># 点击元素</span></span><br><span class="line">submit_button.click()</span><br><span class="line"><span class="comment"># 暂停一下，再退出，否则代码走完程序都退出，浏览器会一闪而过</span></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;enter any key, quit&quot;</span>)</span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>


<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.selenium.dev/documentation/">selenium官网</a></li>
<li><a target="_blank" rel="noopener" href="https://pythondjango.cn/python/tools/7-python_selenium/">selenium使用教程</a></li>
</ul>
<h2 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h2><blockquote>
<p>分享一个简单的例子：爬静态网页，通过requests获取网页html，再通过正则匹配内容，最后把内容下载保存到本地</p>
</blockquote>
<p><a href="../_drafts1/src/crawl_xs.md">李敖回忆录</a></p>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依赖项处理</span></span><br><span class="line">pip freeze &gt; requirements.txt</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://python3webspider.cuiqingcai.com/">Python3网络爬虫开发实战</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yfacesclub/p/11155775.html">selenium提取不了标签文本</a></li>
</ul>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2023/05/15/%E7%88%AC%E8%99%AB%E4%B8%93%E9%A2%98/" data-id="clsrcp7gf000s3gwz9x612hn5" data-title="爬虫笔记" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-金融资料搜集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/13/%E9%87%91%E8%9E%8D%E8%B5%84%E6%96%99%E6%90%9C%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2022-02-13T08:23:43.000Z" itemprop="datePublished">2022-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/13/%E9%87%91%E8%9E%8D%E8%B5%84%E6%96%99%E6%90%9C%E9%9B%86/">金融资料搜集</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><p><a target="_blank" rel="noopener" href="http://data.10jqka.com.cn/">同花顺数据中心</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://data.10jqka.com.cn/ipo/bond/">可转债</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://data.eastmoney.com/money/calc/CalcFundKF.html">理财计算器</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://danjuanapp.com/djmodule/value-center">蛋卷指数估值</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cn.investing.com/rates-bonds/china-10-year-bond-yield">十年期国债收益率</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jisilu.cn/data/new_stock/winning/">新股市值配售&#x2F;收益计算器</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://data.eastmoney.com/xg/xg/default.html">新股申购</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://data.eastmoney.com/kzz/default.html">可转债申购</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://finance.sina.com.cn/stock/hkstock/anh.shtml">A+H上市公司</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://stockpage.10jqka.com.cn/HSAHP/">恒生AH溢价指数</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.csindex.com.cn/zh-CN/downloads/index-information">中证指数估值</a></p>
</li>
</ul>
<h2 id="CPI，PPI，GDP"><a href="#CPI，PPI，GDP" class="headerlink" title="CPI，PPI，GDP"></a>CPI，PPI，GDP</h2><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9B%BD%E5%86%85%E7%94%9F%E4%BA%A7%E6%80%BB%E5%80%BC/31864?fromtitle=gdp&fromid=41201&fr=aladdin">GDP</a></p>
<p><a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/73c3ce28e24f9de50243d95a.html">说说CPI是什么意思？？</a></p>
<p><a href="../_drafts1/ppi%E4%B8%8Ecpi.md">ppi与cpi</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2022/02/13/%E9%87%91%E8%9E%8D%E8%B5%84%E6%96%99%E6%90%9C%E9%9B%86/" data-id="clsrcp7ge000r3gwzb644e5sj" data-title="金融资料搜集" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%91%E8%9E%8D/" rel="tag">金融</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-UML类图关系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/08/UML%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2021-01-08T10:23:00.000Z" itemprop="datePublished">2021-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/08/UML%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB/">UML类图关系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在UML类图中，常见的有以下几种关系: </p>
<h1 id="继承-泛化"><a href="#继承-泛化" class="headerlink" title="继承(泛化)"></a>继承(泛化)</h1><p>继承也被称为Is-A关系, 自行车是车、猫是动物</p>
<p>表示：泛化关系用一条带空心箭头的直接表示</p>
<img src="../img/3424242343.jpg" width="50%" />

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>接口实现</p>
<img src="../img/1582868458sadasda.jpg" width="50%" />

<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>Uses-A 关系</p>
<p>它用于定义一个类以某种方式依赖于另一个类，而另一个类可能依赖于或不依赖于第一个类。通常，在面向对象的编程语言中，依赖关系用于描述一个类在方法的声明中是否包含第二个类的参数，或者说它只是通过方法将第二个类传递给其他类，而不是使用方法来创建第二个类的实例。</p>
<p>依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p>
<p>在最终代码中，依赖关系体现为<strong>类构造方法</strong>及<strong>类方法</strong>的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p>
<p>表示：依赖关系是用一套带箭头的虚线表示的。B依赖于A，描述一个对象在运行期间会用到另一个对象的关系</p>
<img src="../img/457769fd.jpg" width="50%" />

<h1 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h1><p>Has-A关系</p>
<p>关联表示两个实体之间的关系。有两种类型的关联：组合和聚合。通常，关联关系由箭头表示。</p>
<p>如果特别强调方向，如下图，表示B知道A，但 A不知道B；</p>
<img src="../img/43545432da.jpg" width="50%" />


<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>整体和部分不是强依赖的。</p>
<p>一个类在逻辑上包含另一个类，但所包含的类的实例又可以独立于第一个类在其上下文之外生存，或者可以被其他的类所引用。</p>
<p>例如，部门与教师间存在Has-A关系，每位教师必须属于部门，但如果部门不再存在，教师仍然可以处于活动状态,</p>
<p>老师聚合到部门上，或者部门由老师组成。</p>
<p>表示：聚合关系用一条带空心菱形箭头的直线表示</p>
<img src="../img/4534534fjsd.jpg" width="50%" />


<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>一个类是另一个类的组成部分就称两者间存在组合关系。这有点类似于聚合，不同之处在于当主类不再存在时，依赖类不再存在。例如，房子（House）由房间（Room）组成，但如果房子被销毁，房间就不再存在，</p>
<p>表示：组合关系用一条带实心菱形箭头直线表示。</p>
<img src="../img/4564645656fscas.jpg" width="50%" />

<h1 id="依赖与关联的区别"><a href="#依赖与关联的区别" class="headerlink" title="依赖与关联的区别"></a>依赖与关联的区别</h1><p>关联：互相贯连的意思，是比较强的关系，是长期关系。<br>类A关联B的含义是：如果实例化一个A类的对象，同时会有一个B类的对象被实例化。</p>
<p>依赖：成瘾的意思，玩游戏上瘾，你也可以戒掉，所以依赖只是临时关系</p>
<h1 id="关系整合图"><a href="#关系整合图" class="headerlink" title="关系整合图"></a>关系整合图</h1><p>来源于网上<br><img src="./img/9dc3cf58ccbf6c81a82b426bb53eb13532fa40d1.png" width="100%" /></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#id2">看懂UML类图和时序图</a></li>
<li><a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/ad310e80f7d5c01848f49e6b.html">UML类图几种关系的总结（图文并茂、案例详解）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fe949c2f081a">继承、实现、依赖、关联、聚合、组合的联系与区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ochangwen/article/details/72621702">UML类图关系(泛化 、实现、依赖、关联、聚合、组合)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/olvo/archive/2012/05/03/2481014.html">UML类图关系（泛化 、继承、实现、依赖、关联、聚合、组合）</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2021/01/08/UML%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB/" data-id="clsrcp7g900063gwzg3zwg54q" data-title="UML类图关系" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UML/" rel="tag">UML</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Android面试题整理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/07/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2020-02-07T10:23:53.000Z" itemprop="datePublished">2020-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/07/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">Android面试题整理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Android-Handler消息机制"><a href="#Android-Handler消息机制" class="headerlink" title="Android Handler消息机制"></a>Android Handler消息机制</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c74b64a6fb9a049be5e22fc#heading-17">参考链接</a></p>
</blockquote>
<ol>
<li>Handler 的背后有 Looper、MessageQueue 支撑，Looper 负责消息分发，MessageQueue 负责消息管理；</li>
<li>在创建 Handler 之前一定需要先创建 Looper；</li>
<li>Looper 有退出的功能，但是主线程的 Looper 不允许退出；</li>
<li>异步线程的 Looper 需要自己调用 Looper.myLooper().quit();  退出；</li>
<li>Runnable 被封装进了 Message，可以说是一个特殊的 Message；</li>
<li>Handler.handleMessage() 所在的线程是 Looper.loop() 方法被调用的线程，也可以说成 Looper 所在的线程，并不是创建 Handler 的线程；</li>
<li>使用内部类的方式使用 Handler 可能会导致内存泄露，即便在 Activity.onDestroy 里移除延时消息，必须要写成静态内部类；</li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/34652589/answer/90344494">Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</a> 阻塞线程，处于休眠状态，但不耗用CPU资源</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gs344937933/article/details/89815855">Android卡顿优化–卡顿检测</a> 卡顿检测工具里面有用到Looper</li>
</ol>
<p>主线程的死循环一直运行是不是特别消耗CPU资源呢？ 其实不然，这里就涉及到Linux pipe&#x2F;epoll机制，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，详情见Android消息机制1-Handler(Java层)，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I&#x2F;O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
<h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5951ebdd2a7e">深入理解事件分发 ViewGroup.mFirstTouchTarget的设计</a></p>
<blockquote>
<p>mFirstTouchTarget的作用是什么，记录后续事件派发的目标</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jymblog/p/12178527.html">你真的看懂Android事件分发了吗？</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本源码来自 api 28,不同版本略有不同。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步：处理拦截</span></span><br><span class="line">   <span class="type">boolean</span> intercepted;  </span><br><span class="line">     <span class="comment">// 注意这个条件，后者代表着有子view消费事件。后面会讲</span></span><br><span class="line">   <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 子view调用了parent.requestDisallowInterceptTouchEvent干预父布局的拦截，不让它爸拦截它</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">             intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">             ev.setAction(action); </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             intercepted = <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//既不是DOWN事件，mFirstTouchTarget还是null，这种情况挺常见：如果ViewGroup的所有的子View都不消费				//事件，那么当ACTION_MOVE等非DOWN事件到来时，都被拦截了。</span></span><br><span class="line">         intercepted = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，分发ACTION_DOWN</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">alreadyDispatchedToNewTouchTarget</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//注意这个变量,会用到</span></span><br><span class="line">   <span class="comment">// 不拦截才会分发它，如果拦截了，就不分发ACTION_DOWN了</span></span><br><span class="line">    <span class="keyword">if</span> (!intercepted) &#123;</span><br><span class="line">        <span class="comment">//处理DOWN事件，捕获第一个被触摸的mFirstTouchTarget，mFirstTouchTarget很重要，</span></span><br><span class="line">        保存了消费了ACTION_DOWN事件的子view</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(ev.getAction == MotionEvent.ACTION_DOWN)</span> &#123;</span><br><span class="line">            <span class="comment">//遍历所有子view(看源码知子View是按照Z轴排好序的)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">//子view如果：1.不包含事件坐标 2. 在动画  则跳过</span></span><br><span class="line">                <span class="keyword">if</span> (!isTransformedTouchPointInView() || !canViewReceivePointerEvents()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将事件传递给子view的坐标空间，并且判断该子view是否消费这个触摸事件（分发Down事件）</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent()) &#123;</span><br><span class="line">                    <span class="comment">//将该view加入头节点，并且赋值给mFirstTouchTarget</span></span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步：分发非DOWN事件</span></span><br><span class="line">        <span class="comment">//如果没有子view捕获ACTION_DOWN，则交给本ViewGroup处理这个事件。我们看到，这里并没有判断是否拦截，</span></span><br><span class="line">        <span class="comment">//为什么呢？因为如果拦截的话，上面的代码不会执行，就会导致mFirstTouchTarget== null，于是就走下面第一         				//个条件里的逻辑了</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>.dispatchTouchEvent(ev); <span class="comment">//调用View的dispatchTouchEvent，也就是自己处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历touchTargets链表，依次分发事件</span></span><br><span class="line">            <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget) &#123;</span><br><span class="line">                  handled = <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  	<span class="keyword">if</span> (dispatchTransformedTouchEvent()) &#123;</span><br><span class="line">                      handled = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  target = target.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理ACTION_UP和CANCEL，手指抬起来以后相关变量重置</span></span><br><span class="line">        <span class="keyword">if</span> (ev.getAction == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">            reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><h2 id="Android和java基本面试题"><a href="#Android和java基本面试题" class="headerlink" title="Android和java基本面试题"></a>Android和java基本面试题</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhu592665411/article/details/80617081">LRU算法及编码实现LRU策略缓存</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39192827/article/details/85611873">Java：强引用，软引用，弱引用和虚引用</a></p>
<blockquote>
<p><strong>强引用</strong>：必不可少的物品，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。<br><strong>软引用</strong>:用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，<em><strong>只有在内存不足的时候JVM才会回收该对象</strong></em>。<br><strong>弱引用</strong>:用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。</p>
</blockquote>
</li>
<li><p>断点续传的实现</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuanblog/p/4441017.html">Java中HashMap的实现原理</a>  </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60702023">ThreadLoacal用法以及原理</a></p>
<blockquote>
<p>ThreadLocal的实现原理是，在每个线程中维护一个Map，键是ThreadLocal类型，值是Object类型。当想获取ThreadLocal的值时，就从当前线程中拿出Map，然后在把ThreadLocal本身作为键从Map中拿出值返回。  </p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010647035/article/details/79770534">Java线程之如何分析死锁及避免死锁</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903917428424717">Java线程池工作原理浅析</a><br>关键类：ThreadPoolExecutor</p>
</li>
<li><p>Binder 跨进程通信机制<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903589635162126">写给 Android 应用工程师的 Binder 原理剖析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30379689/article/details/79451596">Android进阶——Android跨进程通讯机制之Binder、IBinder、Parcel、AIDL</a></p>
</li>
</ul>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhanglei93/p/6590609.html">Java虚拟机工作原理</a></p>
<h2 id="第三方库源码分析"><a href="#第三方库源码分析" class="headerlink" title="第三方库源码分析"></a>第三方库源码分析</h2><h3 id="OKHTTP"><a href="#OKHTTP" class="headerlink" title="OKHTTP"></a>OKHTTP</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904087788453896">面试官：听说你熟悉OkHttp原理？</a><br>OKHttpClient,RealCall,Dispatcher,AsynCall</p>
<ol>
<li>请求流程</li>
<li>分发器(Dispatcher)</li>
<li>拦截器<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ba6e219a0af6">OkHttp之拦截器</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5e11962afed2">Android okhttp 刷新token</a></li>
<li>缓存</li>
<li>连接池<br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/tangjiean/article/details/51729371">okhttp连接池复用机制</a></li>
<li>okio<br><a target="_blank" rel="noopener" href="https://square.github.io/okio/">官网</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zoudifei/article/details/51232711">深入理解okio的优化思想</a><br>sources和sinks</li>
</ol>
<h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7061714acabe">retrofit源码解析–retrofit创建方法(builder、baseurl、converter…)</a></p>
<h3 id="Rxjava"><a href="#Rxjava" class="headerlink" title="Rxjava"></a>Rxjava</h3><p><a target="_blank" rel="noopener" href="https://gank.io/post/560e15be2dca930e00da1083">给 Android 开发者的 RxJava 详解</a></p>
<ol>
<li>订阅流程<img src="https://github.com/manymore13/img/rxjava_subscribe.png" width="60%" />
从下游一层一层往上游订阅，订阅的时候会调用subscribeActual方法，而在这个方法里订阅上游，每订阅一层会创建一个Observer
，而Observer中持有下游的Observer，当订阅到最顶层的时候，事件创建者开始向下游分发事件比如onNext，onSuccess,往下游传递事件少不了每一层自己创建的Observer。
测试代码如下：
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mySingleObserver = <span class="keyword">object</span> : SingleObserver&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(t: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;------<span class="variable">$t</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubscribe</span><span class="params">(d: <span class="type">Disposable</span>?)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;我被订阅了&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Throwable</span>?)</span></span> &#123;</span><br><span class="line">            e?.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Single.just(<span class="number">1</span>)</span><br><span class="line">            .map(<span class="keyword">object</span> : io.reactivex.rxjava3.functions.Function&lt;<span class="built_in">Int</span>, String&gt; &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(t: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;---<span class="variable">$t</span>&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(mySingleObserver)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
首先看一下代码这里面有几个对象，我们分解一下会更容易理解些</li>
<li>Single.just(1)实际上是创建了SingleJust对象，SingleJust继承于Single。</li>
<li>SingleJust.map()创建了SingleMap对象，SingleMap同样是继承于Single</li>
<li>上面代码最终可以这么看 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SingleJust.SingleMap.subscribe(mySingleObserver)</span><br></pre></td></tr></table></figure></li>
<li>subscribe方法是SingleMap对象的方法，也是Single类中的方法</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> void subscribe(<span class="meta">@NonNull</span> SingleObserver&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        Objects.requireNonNull(observer, <span class="string">&quot;observer is null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">        Objects.requireNonNull(observer, <span class="string">&quot;The RxJavaPlugins.onSubscribe hook returned a null SingleObserver. Please check the handler provided to RxJavaPlugins.setOnSingleSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 接着上面步骤来，它其实调用的SingleMap类的subscribeActual方法</span></span><br><span class="line">            subscribeActual(observer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            NullPointerException npe = new NullPointerException(<span class="string">&quot;subscribeActual failed&quot;</span>);</span><br><span class="line">            npe.initCause(ex);</span><br><span class="line">            <span class="keyword">throw</span> npe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>SingleMap源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SingleMap</span>&lt;T, R&gt; <span class="keyword">extends</span> <span class="title class_">Single</span>&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> SingleSource&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">R</span>&gt; mapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SingleMap</span><span class="params">(SingleSource&lt;? extends T&gt; source, Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.source = source;</span><br><span class="line">        <span class="built_in">this</span>.mapper = mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面订阅的时候，实际上调用的就是这个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">subscribeActual</span><span class="params">(<span class="keyword">final</span> SingleObserver&lt;? <span class="built_in">super</span> R&gt; t)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个source是SingleJust对象，也就是SingleMap的上游</span></span><br><span class="line">        source.subscribe(<span class="keyword">new</span> <span class="title class_">MapSingleObserver</span>&lt;T, R&gt;(t, mapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MapSingleObserver</span>&lt;T, R&gt; <span class="keyword">implements</span> <span class="title class_">SingleObserver</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SingleObserver&lt;? <span class="built_in">super</span> R&gt; t;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">R</span>&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapSingleObserver(SingleObserver&lt;? <span class="built_in">super</span> R&gt; t, Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">R</span>&gt; mapper) &#123;</span><br><span class="line">            <span class="built_in">this</span>.t = t;</span><br><span class="line">            <span class="built_in">this</span>.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">            t.onSubscribe(d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(T value)</span> &#123;</span><br><span class="line">            R v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                v = Objects.requireNonNull(mapper.apply(value), <span class="string">&quot;The mapper function returned a null value.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(e);</span><br><span class="line">                onError(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            t.onSuccess(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">            t.onError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.是哪个对象在什么时候创建了子线程，是一种怎样的方式创建的？<br>2.子线程又是如何启动的？<br>3.上游事件是怎么跑到子线程里执行的？<br>4.多次用 subscribeOn 指定上游线程为什么只有第一次有效 ?<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3dd582bb10cc">RxJava 是如何实现线程切换的（上）</a></p>
<h3 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h3><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/guolin_blog/article/details/28863651">Android DiskLruCache完全解析，硬盘缓存的最佳方案</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lmj623565791/article/details/47251585">Android DiskLruCache 源码解析 硬盘缓存的绝佳方案</a></li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuxingrong666/article/details/83869161">HTTPS的数字证书验证原理</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/daxueba-ITdaren/p/6495468.html">证书锁定Certificate Pinning技术</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7158568e4867">SSL&#x2F;TLS 握手过程详解</a></p>
<h2 id="Android架构"><a href="#Android架构" class="headerlink" title="Android架构"></a>Android架构</h2><p><a href="">Android 组件化与插件化</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1b1d77f58e84">Android彻底组件化方案实践</a></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_17766199/category_9270906.html">Android单元测试</a></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b50b017f265da0f7b2f649c">Android 性能优化最佳实践</a></p>
<h3 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h3><ol>
<li>重绘制</li>
<li>include、merge和ViewStub</li>
<li>复杂界面可选择ConstraintLayout，可有效减少层级</li>
<li>View的绘制频率保证60fps是最佳的， onDraw方法中不要做耗时的任务，也不做过多的循环操作，onDraw()中不要创建新的局部对象。</li>
</ol>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><ol>
<li>内存泄露：单例&#x2F;静态变量造成的内存泄漏，匿名内部类&#x2F;非静态内部类</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/sucese/android-open-framework-analysis">Android Open Framework Analysis</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016117569">分享一份非常强势的Android面试题</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jinguangyue/Android-Advanced-Interview">Android-Advanced-Interview</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ee48103f265da76d53c2676">最新 Android 面试点梳理，我收藏了你呢？</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2020/02/07/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" data-id="clsrcp7g500013gwz6o4jfl6k" data-title="Android面试题整理" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-关于读书的事" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/01/%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6%E7%9A%84%E4%BA%8B/" class="article-date">
  <time class="dt-published" datetime="2020-02-01T00:00:00.000Z" itemprop="datePublished">2020-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/01/%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6%E7%9A%84%E4%BA%8B/">关于读书的事</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="为什么碎片化的东西时间长了容易忘记"><a href="#为什么碎片化的东西时间长了容易忘记" class="headerlink" title="为什么碎片化的东西时间长了容易忘记"></a>为什么碎片化的东西时间长了容易忘记</h2><p>碎片化的东西由于缺乏“触点”，和现有知识连不起来，下次想用的时候也想不出来。我上面说自己组织语言写条微博记录下新知识，就是把新知识和已经有的关联一下。如果新知识连不到你的“认知树”上，很快就会忘了，就跟从来没出现过一样。<br><strong>关键是新知识要与大脑中已有的东西联系起来，否则很容易忘记。</strong></p>
<p>大脑的神经网络依赖“关系型数据库”，也就是说，所有知识必须链接到已经有的知识，到用的时候才能翻出来，否则就彻底丢失索引找不到了。大家感慨搞了那么多“碎片化阅读”依旧没什么用，就是因为连不到你的“思想大树”。</p>
<h2 id="怎样在工作间隙看一些书-有很多人学不进去，作者给出的方法"><a href="#怎样在工作间隙看一些书-有很多人学不进去，作者给出的方法" class="headerlink" title="怎样在工作间隙看一些书?有很多人学不进去，作者给出的方法"></a>怎样在工作间隙看一些书?有很多人学不进去，作者给出的方法</h2><p>首先你要想读书，觉得读书有用，其次才是怎样在工作间隙看书，作者给出的方法是抢占式，懂计算机的人都知道这是个操作系统的专用词汇。</p>
<p>作者早年发现最难的事就是开始做一件事，也就是有点闲工夫了，准备看会儿书的时候，转念一想，要不先玩一局《绝地求生》，玩完了《绝地求生》，又转念一想，要不看几个抖音小视频，跟朋友聊两句。每天都这样把时间耗尽了。总体来说，每一天，都抢不到看书学习的<strong>时间片</strong>。</p>
<p>所以，我每天强制要求自己一定要看两页书，看完两页再干别的，就这样，每天都能抢到看书的“时间片”。当你一旦拿起来书，一切就都有了可能。</p>
<p>为了克服懒惰的问题，制订学习计划的时候，关键就是每天目标一定要小，跟自己先妥协了。你不要太为难自己，你不为难“他”，“他”才给你干活。是的，你体内住着一个你根本不了解的人，你得跟“他”多沟通。</p>
<p>为了让自己坚持学习，你要奖励自己。当你持续多长时间搞定一件事之后，你要给自己适当的奖励，比如你每天看两页书的目标坚持了三四十天就奖励一下自己，完全把你自己当成另外一个人，你会惊喜地发现，你完全不了解你自己。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《向上生长》</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2020/02/01/%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6%E7%9A%84%E4%BA%8B/" data-id="clsrcp7gd000o3gwz2lv7acji" data-title="关于读书的事" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-多线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2020-01-05T06:00:00.000Z" itemprop="datePublished">2020-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程相关笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步和异步通常用来形容一次方法调用。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。<strong>异步方法</strong>调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并行的多个任务是真的同时执行(多核多线程), 而对于并发来说，这个过程只是交替的，一会儿执行任务A，一会儿执行任务B，系统会不停地在两者之间切换。</p>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>临界区就是在同一时刻只能有一个任务访问的代码区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject) &#123; </span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用ReentrantLock来实现临界区</p>
<h2 id="阻塞（Blocking）和非阻塞（Non-Blocking）"><a href="#阻塞（Blocking）和非阻塞（Non-Blocking）" class="headerlink" title="阻塞（Blocking）和非阻塞（Non-Blocking）"></a>阻塞（Blocking）和非阻塞（Non-Blocking）</h2><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的<strong>状态</strong>.<br>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。<br>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
<h2 id="死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）"><a href="#死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）" class="headerlink" title="死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）"></a>死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29924795/article/details/72772251">Java多线程的死锁，活锁，饥饿</a></p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指当一个线程修改了某一个共享变量的值时，其他线程是否能够立即知道这个修改。<strong>volatile</strong>关键字并不能真正保证线程安全。它只能确保一个线程修改了数据后，其他线程能够看到这个改动。但当两个线程同时修改某一个数据时，依然会产生冲突。</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>Thread中State枚举定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIME_WAITING,</span><br><span class="line">    TERMINATED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="../_drafts1/img/thread_state.jpg"/>

<blockquote>
<p>NEW状态表示刚刚创建的线程，这种线程还没开始执行。等到线程的start()方法调用时，才表示线程开始执行。当线程执行时，处于RUNNABLE状态，表示线程所需的一切资源都已经准备好了。如果线程在执行过程中遇到了synchronized同步块，就会进入BLOCKED阻塞状态，这时线程就会暂停执行，直到获得请求的锁。WAITING和TIMED_WAITING都表示等待状态，它们的区别是WAITING会进入一个无时间限制的等待，TIMED_WAITING会进行一个有时限的等待。那么等待的线程究竟在等什么呢？一般来说，WAITING的线程正是在等待一些特殊的事件。比如，通过wait()方法等待的线程在等待notify()方法，而通过join()方法等待的线程则会等待目标线程的终止。一旦等到了期望的事件，线程就会再次执行，进入RUNNABLE状态。当线程执行完毕后，则进入TERMINATED状态，表示结束。</p>
</blockquote>
<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ol>
<li>可以继承Thread类</li>
<li>实现Runnable接口</li>
</ol>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>一般来说，线程执行完毕就会结束，无须手工关闭。<br>stop()方法过于暴力，强行把执行到一半的线程终止，可能会引起一些数据不一致的问题。<br>Thread.stop()方法在结束线程时，会直接终止线程，并立即释放这个线程所持有的锁，而这些锁恰恰是用来维持对象一致性的。如果此时，写线程写入数据正写到一半，并强行终止，那么对象就会被写坏，同时，由于锁已经被释放，另外一个等待该锁的读线程就顺理成章地读到了这个不一致的对象，悲剧也就此发生。</p>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>在Java中，线程中断是一种重要的线程协作机制。使用stop方法终止线程是不安全的，官方也不推荐使用，我们可以根据线程的中断状态，自行处理中断逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它通知目标线程中断，也就是设置中断标志位</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 判断线程是否被标记为中断状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 判断是否被中断，并清除当前线程的中断状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p><a href="../_drafts1/src/InterruptDemo.java">中断的Demo</a></p>
<h2 id="wait与notify"><a href="#wait与notify" class="headerlink" title="wait与notify"></a>wait与notify</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// throws IllegalMonitorStateException</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// throws InterruptedException, IllegalMonitorStateException</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>
<p>wait和notify两个方法是Object的方法，不能直接调用这两个方法，你必须在调用前获取object的锁。</p>
<blockquote>
<p>在线程A中，调用了obj.wait()方法，那么线程A就会停止继续执行，转为等待状态。等待到何时结束呢？线程A会一直等到其他线程调用了obj.notify()方法为止。这时，object对象俨然成了多个线程之间的有效通信手段。<br>如果一个线程调用了object.wait()方法，那么它就会进入object对象的等待队列。这个等待队列中，可能会有多个线程，因为系统运行多个线程同时等待某一个对象。当object.notify()方法被调用时，它就会从这个等待队列中随机选择一个线程，并将其唤醒。这里希望大家注意的是，这个选择是不公平的，并不是先等待的线程就会优先被选择，这个选择完全是随机的。</p>
</blockquote>
<p>生产者与消费者<br><img src="/../_drafts1/img/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBlockingQueue</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">   <span class="keyword">private</span> LinkedList&lt;Object&gt; storage;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">MyBlockingQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.maxSize = size;</span><br><span class="line">       storage = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="keyword">while</span> (storage.size() == maxSize) &#123;</span><br><span class="line">           wait();</span><br><span class="line">       &#125;</span><br><span class="line">       storage.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">       notifyAll();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="keyword">while</span> (storage.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           wait();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(storage.remove());</span><br><span class="line">       notifyAll();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>wait()需要被包在while循环里多次判断wait的执行条件，在上面代码中阻塞队列为空时消费者执行wait操作，释放锁资源。</p>
<blockquote>
<p>wait为什么需要包在while循环里多次判断条件？因为假如你不多次判断，而只判断一次的话会出现阻塞队列为空的时候，消费者去取数据。当有A，B两个消费者都在wait状态，此时生产者添加数据到队列执行notify唤醒消费者，消费者B获取到锁资源然后消费它执行notify，有可能唤醒消费者A执行消费操作就出错了，因为队列是没有数据的。所以执行wait之前需要多此判断条件。</p>
</blockquote>
<h2 id="join与yeild"><a href="#join与yeild" class="headerlink" title="join与yeild"></a>join与yeild</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.yield();</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// join调用的是join(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException </span><br></pre></td></tr></table></figure>
<p><strong>Thread.yield</strong>当前线程让出cpu，但要注意，让出CPU并不表示当前线程不执行了。当前线程在让出CPU后，还会进行CPU资源的争夺，但是是否能够再次被分配到就不一定了。如果你觉得一个线程不那么重要，或者优先级非常低，而且又害怕它会占用太多的CPU资源，那么可以在适当的时候调用Thread.yield()方法，给予其他重要线程更多的工作机会。<br><strong>join</strong>是线程中的方法，查看源码得知它本质上时调用wait方法，比如在主线程中调用线程A的join方法，主线程是释放对象A的锁，然后主线程进入waitting状态，直到线程A执行完释放对象A的锁，主线程才有机会继续执行。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aademeng/articles/10882539.html">Java中join()方法的理解</a></p>
<h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><blockquote>
<p> 在java的多线程处理中有线程组ThreadGroup的概念，ThreadGroup是为了方便线程管理出现了，可以统一设定线程组的一些属性，比如setDaemon，设置未处理异常的处理方法，设置统一的安全策略等等；也可以通过线程组方便的获得线程的一些信息。<br>每一个ThreadGroup都可以包含一组的子线程和一组子线程组，在一个进程中线程组是以树形的方式存在，通常情况下根线程组是system线程组。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/laomumu1992/article/details/102905585">java线程组（ThreadGroup）</a></p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41063141/article/details/91939540">java中的用户线程和守护线程</a></p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><blockquote>
<p>线程可以有自己的优先级。优先级高的线程在竞争资源时会更有优势，更<strong>可能</strong>抢占资源。<br>在Java中，使用1到10表示线程优先级，数字越大则优先级越高。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="重入锁ReentrantLock"><a href="#重入锁ReentrantLock" class="headerlink" title="重入锁ReentrantLock"></a>重入锁ReentrantLock</h2><blockquote>
<p>重入锁使用ReentrantLock类来实现,可以完全替代关键字synchronized，在JDK 5.0的早期版本中，重入锁的性能远远优于关键字synchronized，但从JDK 6.0开始，JDK在关键字synchronized上做了大量的优化，使得两者的性能差距并不大。开发人员必须手动指定何时加锁，何时释放锁。也正因为这样，重入锁对逻辑控制的灵活性要远远优于关键字synchronized。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得锁，如果锁已经被占用，则等待</span></span><br><span class="line">lock()：</span><br><span class="line"><span class="comment">// 获得锁，但优先响应中断</span></span><br><span class="line">lockInterruptibly()：</span><br><span class="line"><span class="comment">// 尝试获得锁，如果成功，则返回true，失败返回false。该方法不等待，立即返回</span></span><br><span class="line">tryLock()：</span><br><span class="line"><span class="comment">//在给定时间内尝试获得锁</span></span><br><span class="line">tryLock(<span class="type">long</span> time, TimeUnit unit)：</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">unlock()：</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">      lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... method body</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// ... method body</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一个线程多次获得锁，那么在释放锁的时候，也必须释放相同次数。如果释放锁的次数多了，那么会得到一个java.lang.IllegalMonitorStateException异常，反之，如果释放锁的次数少了，那么相当于线程还持有这个锁，因此，其他线程也无法进入临界区。</p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>ReentrantLock fairLock &#x3D; new ReentrantLock(true) 构造函数中的参数设置为true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公平锁Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fairLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 获到锁&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                fairLock.unlock();    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantLockDemo</span> <span class="variable">reentrantLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLockDemo</span>(); </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(reentrantLockDemo,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(reentrantLockDemo,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">t1 获到锁</span><br><span class="line">t2 获到锁</span><br><span class="line">t1 获到锁</span><br><span class="line">t2 获到锁</span><br><span class="line">...</span><br><span class="line">````</span><br><span class="line">可以看到在公平锁下线程交替获取到锁，显得很公平</span><br><span class="line">ReentrantLock.lock和ReentrantLock.unlock类似于<span class="keyword">synchronized</span>作用。</span><br><span class="line">### Condition使用</span><br><span class="line">&gt;它与wait()方法和notify()方法的作用是大致相同的。但是wait()方法和notify()方法是与<span class="keyword">synchronized</span>关键字合作使用的，而Condition是与重入锁相关联的。通过lock接口（重入锁就实现了这一接口）的Condition <span class="title function_">newCondition</span><span class="params">()</span>方法可以生成一个与当前重入锁绑定的Condition实例。利用Condition对象，我们就可以让线程在合适的时间等待，或者在某一个特定的时刻得到通知，继续执行。</span><br><span class="line"></span><br><span class="line">Condition有几个方法如下</span><br><span class="line"><span class="number">1.</span> await()方法会使当前线程等待，同时释放当前锁，当其他线程中使用signal()方法或者signalAll()方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等待。这和Object.wait()方法相似。</span><br><span class="line"><span class="number">2.</span> awaitUninterruptibly()方法与await()方法基本相同，但是它并不会在等待过程中响应中断。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> singal()方法用于唤醒一个在等待中的线程，singalAll()方法会唤醒所有在等待中的线程。这和Obejct.notify()方法很类似。</span><br><span class="line"></span><br><span class="line">## 线程池</span><br><span class="line">为了避免系统频繁地创建和销毁线程，我们可以让创建的线程复用。</span><br><span class="line">- 线程池的各个参数的含义</span><br><span class="line">```java</span><br><span class="line"><span class="comment">// 初始化线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">        // 核心线程数 正式工数量</span></span><br><span class="line"><span class="params">        <span class="type">int</span> corePoolSize, </span></span><br><span class="line"><span class="params">        // 最大线程数</span></span><br><span class="line"><span class="params">        <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">        // 空闲线程存活的时间</span></span><br><span class="line"><span class="params">        <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">        // 存活时间的单位</span></span><br><span class="line"><span class="params">        TimeUnit unit,</span></span><br><span class="line"><span class="params">        // 用于存放任务的队列</span></span><br><span class="line"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">        // 创建新线程的工厂</span></span><br><span class="line"><span class="params">        ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">        // 处理被拒绝的任务</span></span><br><span class="line"><span class="params">        RejectedExecutionHandler handler</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>
<p>corePoolSize 是核心线程数，也就是常驻线程池的线程数量，与它对应的是 maxPoolSize，表示线程池最大线程数量，当我们的任务特别多而 corePoolSize 核心线程数无法满足需求的时候，就会向线程池中增加线程，以便应对任务突增的情况。<br><img src="/../_drafts1/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"><br>接下来，我们来具体看下这两个参数所代表的含义，以及线程池中创建线程的时机。如上图所示，当提交任务后，线程池首先会检查当前线程数，如果此时线程数小于核心线程数，比如最开始线程数量为 0，则新建线程并执行任务，随着任务的不断增加，线程数会逐渐增加并达到核心线程数，此时如果仍有任务被不断提交，就会被放入 workQueue 任务队列中，等待核心线程执行完当前任务后重新从 workQueue 中提取正在等待被执行的任务。</p>
<p> </p>
<p>此时，假设我们的任务特别的多，已经达到了 workQueue 的容量上限，这时线程池就会启动后备力量，也就是 maxPoolSize 最大线程数，线程池会在 corePoolSize 核心线程数的基础上继续创建线程来执行任务，假设任务被不断提交，线程池会持续创建线程直到线程数达到 maxPoolSize 最大线程数，如果依然有任务被提交，这就超过了线程池的最大处理能力，这个时候线程池就会拒绝这些任务，我们可以看到实际上任务进来之后，线程池会逐一判断 corePoolSize 、workQueue 、maxPoolSize ，如果依然不能满足需求，则会拒绝任务。</p>
<p><img src="/../_drafts1/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8A%A8%E6%80%81%E5%9B%BE.gif"></p>
<ul>
<li>线程池的阻塞队列<br>线程池中的这四个主要组成部分最值得我们关注的就是阻塞队列了，如表格所示，不同的线程池会选用不同的阻塞队列。</li>
</ul>
<p><img src="/../_drafts1/img/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png"></p>
<p>表格左侧是线程池，右侧为它们对应的阻塞队列，你可以看到 5 种线程池对应了 3 种阻塞队列，我们接下来对它们进行逐一的介绍。</p>
<p><strong>LinkedBlockingQueue</strong>     <br>对于 FixedThreadPool 和 SingleThreadExector 而言，它们使用的阻塞队列是容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue，可以认为是无界队列。由于 FixedThreadPool 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。这里需要注意，由于线程池的任务队列永远不会放满，所以线程池只会创建核心线程数量的线程，所以此时的最大线程数对线程池来说没有意义，因为并不会触发生成多于核心线程数的线程。</p>
<p><strong>SynchronousQueue</strong>      <br>第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。</p>
<p>我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。</p>
<p><strong>DelayedWorkQueue</strong>       <br>第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><blockquote>
<p>保证可见性，不保证原子性</p>
</blockquote>
<ul>
<li>volatile 和 synchronized 的关系</li>
</ul>
<p>相似性：volatile 可以看作是一个轻量版的 synchronized，比如一个共享变量如果自始至终只被各个线程赋值和读取，而没有其他操作的话，那么就可以用 volatile 来代替 synchronized 或者代替原子变量，足以保证线程安全。实际上，对 volatile 字段的每次读取或写入都类似于“半同步”——读取 volatile 与获取 synchronized 锁有相同的内存语义，而写入 volatile 与释放 synchronized 锁具有相同的语义。</p>
<p>不可代替：但是在更多的情况下，volatile 是不能代替 synchronized 的，volatile 并没有提供原子性和互斥性。</p>
<p>性能方面：volatile 属性的读写操作都是无锁的，正是因为无锁，所以不需要花费时间在获取锁和释放锁上，所以说它是高性能的，比 synchronized 性能更好。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473">怎样理解阻塞非阻塞与同步异步的区别？</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/guanghe/p/9206635.html">并发之原子性、可见性、有序性</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fan2012huan/article/details/51781443">Java多线程之临界区、ThreadLocal</a><br><a href="">实战java高并发程序设计</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/soaringEveryday/p/4418604.html">Java多线程共享变量控制</a></p>
<h2 id="JMM-java内存模型"><a href="#JMM-java内存模型" class="headerlink" title="JMM(java内存模型)"></a>JMM(java内存模型)</h2><p>重排序，原子性，内存可见性</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><ul>
<li>实现runnable接口的3个好处</li>
</ul>
<ol>
<li>Runnable 与 Thread 类的解耦，Runnable负责执行的内容，Thread 类负责线程启动和属性设置等内容，权责分明。</li>
<li>Runnable可以结合线程池一起使用</li>
<li>Java 语言不支持双继承，如果我们的类一旦继承了 Thread 类，那么它后续就没有办法再继承其他的类，这样一来，如果未来这个类需要继承其他类实现一些功能上的拓展，它就没有办法做到了，相当于限制了代码未来的可拓展性。</li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/vking_wang/article/details/9982709">volatile的适用场景</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2020/01/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="clsrcp7ge000p3gwz2hl9dhbq" data-title="多线程相关笔记" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-协程使用指南" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/02/%E5%8D%8F%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" class="article-date">
  <time class="dt-published" datetime="2020-01-02T07:23:43.000Z" itemprop="datePublished">2020-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/02/%E5%8D%8F%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">协程使用指南</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="协程使用指南"><a href="#协程使用指南" class="headerlink" title="协程使用指南"></a>协程使用指南</h1><h2 id="协程介绍"><a href="#协程介绍" class="headerlink" title="协程介绍"></a>协程介绍</h2><blockquote>
<p>协程是一种并发设计模式，是一套基于线程来实现的API，可以看作是轻量级线程。<br>协程的一个好处是，当涉及到开发人员时，编写非阻塞代码与编写阻塞代码基本相同。编程模型本身并没有真正改变。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1&#x27;</span></span><br><span class="line"><span class="comment">// 可选 Android中使用协程</span></span><br><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="协程的用法"><a href="#协程的用法" class="headerlink" title="协程的用法"></a>协程的用法</h2><h3 id="创建一个协程，并执行"><a href="#创建一个协程，并执行" class="headerlink" title="创建一个协程，并执行"></a>创建一个协程，并执行</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在后台启动一个新的协程并执行</span></span><br><span class="line">    GlobalScope.launch &#123; </span><br><span class="line">        <span class="comment">// 非阻塞的等待 1 秒钟（默认时间单位是毫秒）</span></span><br><span class="line">        delay(<span class="number">1000L</span>) </span><br><span class="line">        <span class="comment">// 在延迟后打印输出</span></span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>) </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 协程已在等待时主线程还在继续</span></span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) </span><br><span class="line">    <span class="comment">// 阻塞主线程 2 秒钟来保证 JVM 存活</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行的结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello,</span><br><span class="line">World!</span><br></pre></td></tr></table></figure>
<p>我们使用<strong>GlobalScope.launch</strong>创建一个协程，并执行它，后面大括号里包着的是协程要执行的内容，类似于线程中的run方法体。</p>
<ul>
<li><strong>delay</strong>方法只能在协程内部使用，它用于挂起协程，但是不会阻塞当前协程所在的线程。</li>
<li><strong>Thread.sleep</strong>会阻塞当前线程，也就是说当前线程被阻塞在那暂时不能做别的事情了</li>
</ul>
<hr>
<p>关于协程的方法只能在协程体里面执行，所以为了方便测试协程代码，我准备使用<strong>runBlocking</strong>把main方法包起来。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *显式指定了其返回类型 Unit，</span></span><br><span class="line"><span class="comment"> * 因为在 Kotlin 中 main 函数必须返回 Unit 类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>= runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 打印当前线程名称</span></span><br><span class="line">    println(Thread.currentThread().name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main</span><br></pre></td></tr></table></figure>
<p>runBlocking方法运行一个新的协程并且阻塞当前线程，上面的代码中包裹的是main方法，所以阻塞的是main线程</p>
<h3 id="协程挂起"><a href="#协程挂起" class="headerlink" title="协程挂起"></a>协程挂起</h3><blockquote>
<p>我们用suspend修饰符来标记函数<br>挂起函数只被允许在协程或另一个挂起函数中调用</p>
</blockquote>
<p>我们先看一个先获取token，再登录的例子，里面用到挂起函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.measureTimeMillis</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>= runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> time = measureTimeMillis&#123;</span><br><span class="line">        <span class="keyword">val</span> token = getToken()</span><br><span class="line">        <span class="keyword">val</span> loginInfo = login(token)</span><br><span class="line">        println(loginInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟接口获取token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getToken</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;woshitoken&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟接口登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(token:<span class="type">String</span>)</span></span>:String &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;my token is: <span class="variable">$token</span> , login success&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my token <span class="keyword">is</span>: woshitoken , login success</span><br><span class="line">Completed <span class="keyword">in</span> <span class="number">2012</span> ms</span><br></pre></td></tr></table></figure>
<ul>
<li>我对挂起的理解：<blockquote>
<p>在上面的代码中有两个挂起函数getToken和login，当程序逻辑走到挂起函数getToken()那里，当前协程被挂起,getToken()被抛出去执行，你可以指定在哪一个线程池中执行，当getToken在外部执行完后再恢复刚才挂起的协程，协程代码继续执行。</p>
</blockquote>
</li>
</ul>
<h3 id="async-并发"><a href="#async-并发" class="headerlink" title="async 并发"></a>async 并发</h3><blockquote>
<p>在概念上，async 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。<a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/coroutines/composing-suspending-functions.html#%E4%BD%BF%E7%94%A8-async-%E5%B9%B6%E5%8F%91">转自 kotlincn.net</a></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        <span class="keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        println(<span class="string">&quot;The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 假设我们在这里做了些有用的事</span></span><br><span class="line">    delay(<span class="number">1000L</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 假设我们在这里也做了些有用的事</span></span><br><span class="line">    delay(<span class="number">1000L</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The answer <span class="keyword">is</span> <span class="number">42</span></span><br><span class="line">Completed <span class="keyword">in</span> <span class="number">1055</span> ms</span><br></pre></td></tr></table></figure>
<p>两个协程是并发执行。<br><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/coroutines/composing-suspending-functions.html#%E6%83%B0%E6%80%A7%E5%90%AF%E5%8A%A8%E7%9A%84-async">惰性启动的-async</a></p>
<h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html">官方协程指南</a><br><a target="_blank" rel="noopener" href="https://kaixue.io/kotlin-coroutines-2/">kaixue</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903921337516040">如何正确的在 Android 上使用协程 ？</a><br><a target="_blank" rel="noopener" href="https://www.bennyhuo.com/2020/03/14/coroutine-flow/">协程博客</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2020/01/02/%E5%8D%8F%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" data-id="clsrcp7ga00083gwz4pwn7dbm" data-title="协程使用指南" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%8F%E7%A8%8B/" rel="tag">协程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-NDK编程笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/02/NDK%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2020-01-02T06:23:38.000Z" itemprop="datePublished">2020-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/02/NDK%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">NDK编程笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="NDK编程笔记"><a href="#NDK编程笔记" class="headerlink" title="NDK编程笔记"></a>NDK编程笔记</h1><h2 id="FFMpeg国内镜像"><a href="#FFMpeg国内镜像" class="headerlink" title="FFMpeg国内镜像"></a><a target="_blank" rel="noopener" href="https://gitee.com/mirrors/ffmpeg">FFMpeg国内镜像</a></h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/ndk/guides">NDK指南</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/ndk/reference">NDK库Api</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/ndk/samples">官方例子</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/han1202012/category_9493908.html">Android NDK 开发-韩曙亮</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011609853/article/details/105648099">NDK r21编译FFmpeg 4.2.2（x86、x86_64、armv7、armv8）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Javernaut/ffmpeg-android-maker">ffmpeg-android-maker</a>,<a target="_blank" rel="noopener" href="https://github.com/Javernaut/ffmpeg-android-maker/wiki/Setting-the-FFmpeg-version">wiki</a><br>推荐使用这个脚本编译FFmpeg<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ffmpeg-android-maker.sh -abis=x86_64 -android=21 --source-git-branch=release/4.2.3</span><br></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="http://trac.ffmpeg.org/wiki/CompilationGuide/Android">wikiCompilationGuide&#x2F;Android</a> </li>
<li><a target="_blank" rel="noopener" href="https://trac.ffmpeg.org/wiki/CompilationGuide/Generic">FFmpeg官方WIKI</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lbcab/article/details/72771729">Android gradle SourceSets介绍与使用</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chaoqiangscu/article/details/83023762">Android：JNI调用C++自定义类的详细方法</a></li>
</ol>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li>NDK是什么？<br>一套可以帮助你把原生代码(c&#x2F;c++)嵌入到Android应用中的工具</li>
<li>适用性<br>重用已经有的原生库，计算密集型应用用原生代码可以提高性能，比如游戏</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">JNI ORACLE官方介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013278099/article/details/52003759">了解JNI动态注册native方法</a></li>
</ol>
<h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(预处理)--&gt;B(编译)</span><br><span class="line">B--&gt;C(汇编)</span><br><span class="line">C--&gt;D(链接)</span><br><span class="line">```   </span><br><span class="line">- **预处理(Preprocessing)**</span><br><span class="line">   完成宏替换，文件引入，以及去除空行，注释等，为下一步编译做准备。也就是对各种预处理命令进行处理，包括头文件的包含，宏定义的扩展，条件编译的选择等。</span><br><span class="line">    ```shell</span><br><span class="line">    gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>
<p>选项-E让gcc在预处理结束后停止编译，test.i文件为预处理后输出的文件。-o指定输出文件</p>
<ul>
<li><p><strong>编译(Compilation)</strong><br><img src="/../_drafts1/img/%E7%BC%96%E8%AF%91.png" alt="编译">  </p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure>
<p>选项-S让gcc在编译结束后停止编译过程,test.s文件为编译后生成的汇编代码。</p>
</li>
<li><p><strong>汇编</strong><br>汇编就是把编译阶段生成的.s文件转成二进制<strong>目标代码</strong>，也就是机器代码(01序列)。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure>
<p>选项-c让gcc在汇编结束后停止编译过程，test.o文件为生成的机器码目标文件。</p>
</li>
<li><p><strong>链接</strong><br>链接就是将多个目标文件以及所需的库文件链接生成可执行目标文件的过程。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o -o test</span><br></pre></td></tr></table></figure>
<p>  -o本质上是一个重命名选项。不使用-o选项时，默认生成的是a.out文件</p>
</li>
<li><p><strong>一次性生成可执行文件</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/codingmengmeng/p/6046481.html">静态库和动态库的区别</a></p>
<h2 id="CMake使用"><a href="#CMake使用" class="headerlink" title="CMake使用"></a>CMake使用</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bigdog_1027/article/details/79113342">cmake学习笔记之add_library、target_link_libraries和link_directories</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e51547d288fd">FFmpeg（四）：CMake移植FFmpeg的静态库到AndroidStudio中</a></p>
<h2 id="编译工具-推荐使用CMake"><a href="#编译工具-推荐使用CMake" class="headerlink" title="编译工具(推荐使用CMake)"></a>编译工具(推荐使用CMake)</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoyu_93/article/details/53082088">CMake,Ndkbuild不同配置方法以及区别</a>   </li>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/projects/configure-cmake#add-ndk-api">配置CMake-官方</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/projects/configure-cmake#add-ndk-api">如何添加NDK API</a><br>添加ndk中的日志打印库<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.4</span><span class="number">.1</span>)</span><br><span class="line">include_directories( src/main/cpp/include/ )</span><br><span class="line"></span><br><span class="line">add_library(hello-jni SHARED</span><br><span class="line">            src/main/cpp/Hello.c)</span><br><span class="line"></span><br><span class="line">add_library(callC SHARED</span><br><span class="line">        src/main/cpp/javaCallC.c)</span><br><span class="line"></span><br><span class="line">add_library(calljava SHARED</span><br><span class="line">        src/main/cpp/cCallJava.cpp)</span><br><span class="line"></span><br><span class="line">find_library(log-lib</span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line"># Include libraries needed <span class="keyword">for</span> hello-jni lib</span><br><span class="line"><span class="title function_">target_link_libraries</span><span class="params">(hello-jni</span></span><br><span class="line"><span class="params">                      android</span></span><br><span class="line"><span class="params">                      log)</span></span><br><span class="line">target_link_libraries( calljava  $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure>
具体配置介绍参考 <a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/projects/configure-cmake#add-ndk-api">配置CMake-官方</a></li>
</ol>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ol>
<li>生成头文件:javah -d 存放的目录　完整类</li>
<li>查看方法签名:javap　-s 完整类</li>
<li>kotlin类头文件生成必须要到 路径(app&#x2F;build&#x2F;tmp&#x2F;kotlin-classes&#x2F;debug)下javah <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">javap -s com.cn.katefm.jni.CcallJava</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">## java调用C</span><br><span class="line">直接看源码</span><br><span class="line">java或者kotlin要调用ｃ/c++函数，必须声明<span class="keyword">native</span>方法</span><br><span class="line">他们用的关键字不一样。</span><br><span class="line">```kotlin</span><br><span class="line"><span class="keyword">package</span> com.cn.katefm.jni</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * c代码调用java代码</span></span><br><span class="line"><span class="comment"> * 查看该类所有方法签名</span></span><br><span class="line"><span class="comment"> * ~/AndroidStudioProjects/KateFM/app/build/tmp/kotlin-classes/debug$ javap -s com.cn.katefm.jni.CcallJava</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CcallJava</span> &#123;</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;calljava&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    external fun <span class="title function_">cCallmultiply</span><span class="params">(a: Int, b: Int)</span>:Int</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘法运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fun <span class="title function_">multiply</span><span class="params">(a: Int, b: Int)</span> = a * b</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cn.katefm.jni;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java代码调用C代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaCallC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;callC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两数想家</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串拼接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">sayHello</span><span class="params">(String s)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改字符串值并返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intArray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span>[] increaseArrayEles(<span class="type">int</span>[] intArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码检验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pwd 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">checkPwd</span><span class="params">(String pwd)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by manymore13 on 20-6-15.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// https://developer.android.com/studio/projects/configure-cmake</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;com_cn_katefm_jni_JNI.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">Java_com_cn_katefm_jni_JavaCallC_add</span></span></span><br><span class="line"><span class="function">        <span class="params">(JNIEnv *env, jobject jobj, jint x, jint y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">jstring <span class="title">Java_com_cn_katefm_jni_JavaCallC_sayHello</span></span></span><br><span class="line"><span class="function">        <span class="params">(JNIEnv *env, jobject jobj, jstring str)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *jniStr = <span class="string">&quot;我是jni&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *jStr = (*env)-&gt;<span class="built_in">GetStringUTFChars</span>(env, str, <span class="number">0</span>);</span><br><span class="line">    jniStr = <span class="built_in">strcat</span>(jniStr, jStr);</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;<span class="built_in">NewStringUTF</span>(env, jniStr);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jintArray JNICALL <span class="title">Java_com_cn_katefm_jni_JavaCallC_increaseArrayEles</span></span></span><br><span class="line"><span class="function">        <span class="params">(JNIEnv *env, jobject jobj, jintArray jArray)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = (*env)-&gt;<span class="built_in">GetArrayLength</span>(env, jArray);</span><br><span class="line">    jint *jIntArray = (*env)-&gt;<span class="built_in">GetIntArrayElements</span>(env, jArray, JNI_FALSE);</span><br><span class="line">    jintArray resultArray = (*env)-&gt;<span class="built_in">NewIntArray</span>(env, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        jint *current = jIntArray + i;</span><br><span class="line">        *current = +<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (*env)-&gt;<span class="built_in">SetIntArrayRegion</span>(env, resultArray, <span class="number">0</span>, len, jIntArray);</span><br><span class="line">    <span class="keyword">return</span> resultArray;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Java_com_cn_katefm_jni_JavaCallC_checkPwd</span></span></span><br><span class="line"><span class="function">        <span class="params">(JNIEnv *env, jobject jobj, jstring passWord)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *origin = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *userPassWord = (*env)-&gt;<span class="built_in">GetStringUTFChars</span>(env, passWord, JNI_FALSE);</span><br><span class="line">    <span class="type">int</span> code = <span class="built_in">strcmp</span>(origin, userPassWord);</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="C调用java"><a href="#C调用java" class="headerlink" title="C调用java"></a>C调用java</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by manymore13 on 20-6-16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;com_cn_katefm_jni_CcallJava.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  LOG_TAG  <span class="string">&quot;test&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGI(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGE(...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGD(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jint JNICALL <span class="title">Java_com_cn_katefm_jni_CcallJava_cCallmultiply</span></span></span><br><span class="line"><span class="function">        <span class="params">(JNIEnv *env, jobject jobj, jint a, jint b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 得到字节码</span></span><br><span class="line">    jclass jclazz = (env)-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/cn/katefm/jni/CcallJava&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 得到方法</span></span><br><span class="line">    jmethodID jmethodId = env-&gt;<span class="built_in">GetMethodID</span>(jclazz, <span class="string">&quot;multiply&quot;</span>, <span class="string">&quot;(II)I&quot;</span>);</span><br><span class="line">    <span class="comment">//3.实例化该类语言打印日志</span></span><br><span class="line">    <span class="comment">//jobject  jobject = env-&gt;AllocObject(jclazz);</span></span><br><span class="line">    <span class="comment">//4.调用该方法</span></span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;我是日志打印&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">CallIntMethod</span>(jobj,jmethodId,a,b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>native层调用java层弹Toast</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">jclass</span> <span class="variable">jclazz</span> <span class="operator">=</span> env-&gt;FindClass(<span class="string">&quot;com/cn/katefm/MainActivity&quot;</span>);</span><br><span class="line">    <span class="type">jmethodID</span> <span class="variable">jmethodId</span> <span class="operator">=</span> env-&gt;GetMethodID(jclazz, <span class="string">&quot;showToast&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(thiz, jmethodId, str);</span><br></pre></td></tr></table></figure>

<h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><ol>
<li>[解决Error: undefined reference to &#96;__android_log_print’](<a target="_blank" rel="noopener" href="https://blog.csdn.net/guyuealian/article/details/78310025">https://blog.csdn.net/guyuealian/article/details/78310025</a>)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://manymore13.github.io/2020/01/02/NDK%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" data-id="clsrcp7g800043gwz70gygape" data-title="NDK编程笔记" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NDK/" rel="tag">NDK</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NDK/" rel="tag">NDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/" rel="tag">UML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E7%A8%8B/" rel="tag">协程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%91%E8%9E%8D/" rel="tag">金融</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/NDK/" style="font-size: 10px;">NDK</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/%E5%8D%8F%E7%A8%8B/" style="font-size: 10px;">协程</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 10px;">读书</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 10px;">金融</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/02/18/NIO%E7%AC%94%E8%AE%B0/">NIO笔记</a>
          </li>
        
          <li>
            <a href="/2024/02/18/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2023/05/15/%E7%88%AC%E8%99%AB%E4%B8%93%E9%A2%98/">爬虫笔记</a>
          </li>
        
          <li>
            <a href="/2022/02/13/%E9%87%91%E8%9E%8D%E8%B5%84%E6%96%99%E6%90%9C%E9%9B%86/">金融资料搜集</a>
          </li>
        
          <li>
            <a href="/2021/01/08/UML%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB/">UML类图关系</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 manymore13<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>